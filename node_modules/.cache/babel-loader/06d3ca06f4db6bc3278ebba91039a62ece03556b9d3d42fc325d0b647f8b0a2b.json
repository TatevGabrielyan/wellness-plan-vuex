{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * DevExtreme (esm/viz/series/scatter_series.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { extend as _extend } from \"../../core/utils/extend\";\nimport { each as _each } from \"../../core/utils/iterator\";\nimport rangeCalculator from \"./helpers/range_data_calculator\";\nimport { isDefined as _isDefined, isString as _isString } from \"../../core/utils/type\";\nimport { map as _map, normalizeEnum as _normalizeEnum, convertXYToPolar } from \"../core/utils\";\nimport { noop as _noop } from \"../../core/utils/common\";\nvar math = Math;\nvar _abs = math.abs;\nvar _sqrt = math.sqrt;\nvar _max = math.max;\nvar DEFAULT_TRACKER_WIDTH = 12;\nvar DEFAULT_DURATION = 400;\nvar HIGH_ERROR = \"highError\";\nvar LOW_ERROR = \"lowError\";\nvar VARIANCE = \"variance\";\nvar STANDARD_DEVIATION = \"stddeviation\";\nvar STANDARD_ERROR = \"stderror\";\nvar PERCENT = \"percent\";\nvar FIXED = \"fixed\";\nvar UNDEFINED = \"undefined\";\nvar DISCRETE = \"discrete\";\nvar LOGARITHMIC = \"logarithmic\";\nvar DATETIME = \"datetime\";\nvar chart = {};\nvar polar = {};\nfunction sum(array) {\n  var result = 0;\n  _each(array, function (_, value) {\n    result += value;\n  });\n  return result;\n}\nfunction isErrorBarTypeCorrect(type) {\n  return [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR].includes(type);\n}\nfunction variance(array, expectedValue) {\n  return sum(_map(array, function (value) {\n    return (value - expectedValue) * (value - expectedValue);\n  })) / array.length;\n}\nfunction calculateAvgErrorBars(result, data, series) {\n  var errorBarsOptions = series.getOptions().valueErrorBar;\n  var valueField = series.getValueFields()[0];\n  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n  if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\n    var fusionData = data.reduce(function (result, item) {\n      if (_isDefined(item[lowValueField])) {\n        result[0] += item[valueField] - item[lowValueField];\n        result[1]++;\n      }\n      if (_isDefined(item[highValueField])) {\n        result[2] += item[highValueField] - item[valueField];\n        result[3]++;\n      }\n      return result;\n    }, [0, 0, 0, 0]);\n    if (fusionData[1]) {\n      result[lowValueField] = result[valueField] - fusionData[0] / fusionData[1];\n    }\n    if (fusionData[2]) {\n      result[highValueField] = result[valueField] + fusionData[2] / fusionData[3];\n    }\n  }\n  return result;\n}\nfunction calculateSumErrorBars(result, data, series) {\n  var errorBarsOptions = series.getOptions().valueErrorBar;\n  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n  if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\n    result[lowValueField] = 0;\n    result[highValueField] = 0;\n    result = data.reduce(function (result, item) {\n      result[lowValueField] += item[lowValueField];\n      result[highValueField] += item[highValueField];\n      return result;\n    }, result);\n  }\n  return result;\n}\nfunction getMinMaxAggregator(compare) {\n  return (_ref, series) => {\n    var {\n      intervalStart: intervalStart,\n      intervalEnd: intervalEnd,\n      data: data\n    } = _ref;\n    var valueField = series.getValueFields()[0];\n    var targetData = data[0];\n    targetData = data.reduce((result, item) => {\n      var value = item[valueField];\n      if (null === result[valueField]) {\n        result = item;\n      }\n      if (null !== value && compare(value, result[valueField])) {\n        return item;\n      }\n      return result;\n    }, targetData);\n    return _extend({}, targetData, {\n      [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\n    });\n  };\n}\nfunction checkFields(data, fieldsToCheck, skippedFields) {\n  var allFieldsIsValid = true;\n  for (var field in fieldsToCheck) {\n    var isArgument = \"argument\" === field;\n    if (isArgument || \"size\" === field ? !_isDefined(data[field]) : void 0 === data[field]) {\n      var selector = fieldsToCheck[field];\n      if (!isArgument) {\n        skippedFields[selector] = (skippedFields[selector] || 0) + 1;\n      }\n      allFieldsIsValid = false;\n    }\n  }\n  return allFieldsIsValid;\n}\nvar baseScatterMethods = {\n  _defaultDuration: DEFAULT_DURATION,\n  _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,\n  _applyStyle: _noop,\n  _updateOptions: _noop,\n  _parseStyle: _noop,\n  _prepareSegment: _noop,\n  _drawSegment: _noop,\n  _appendInGroup: function () {\n    this._group.append(this._extGroups.seriesGroup);\n  },\n  _createLegendState: function (styleOptions, defaultColor) {\n    return {\n      fill: styleOptions.color || defaultColor,\n      hatching: styleOptions.hatching ? _extend({}, styleOptions.hatching, {\n        direction: \"right\"\n      }) : void 0\n    };\n  },\n  _applyElementsClipRect: function (settings) {\n    settings[\"clip-path\"] = this._paneClipRectID;\n  },\n  _applyMarkerClipRect: function (settings) {\n    settings[\"clip-path\"] = this._forceClipping ? this._paneClipRectID : null;\n  },\n  _createGroup: function (groupName, parent, target, settings) {\n    var group = parent[groupName] = parent[groupName] || this._renderer.g();\n    target && group.append(target);\n    settings && group.attr(settings);\n  },\n  _applyClearingSettings: function (settings) {\n    settings.opacity = null;\n    settings.scale = null;\n    if (this._options.rotated) {\n      settings.translateX = null;\n    } else {\n      settings.translateY = null;\n    }\n  },\n  _createGroups: function () {\n    this._createGroup(\"_markersGroup\", this, this._group);\n    this._createGroup(\"_labelsGroup\", this);\n  },\n  _setMarkerGroupSettings: function () {\n    var settings = this._createPointStyles(this._getMarkerGroupOptions()).normal;\n    settings.class = \"dxc-markers\";\n    settings.opacity = 1;\n    this._applyMarkerClipRect(settings);\n    this._markersGroup.attr(settings);\n  },\n  getVisibleArea: function () {\n    return this._visibleArea;\n  },\n  areErrorBarsVisible: function () {\n    var errorBarOptions = this._options.valueErrorBar;\n    return errorBarOptions && this._errorBarsEnabled() && \"none\" !== errorBarOptions.displayMode && (isErrorBarTypeCorrect(_normalizeEnum(errorBarOptions.type)) || _isDefined(errorBarOptions.lowValueField) || _isDefined(errorBarOptions.highValueField));\n  },\n  groupPointsByCoords(rotated) {\n    var cat = [];\n    _each(this.getVisiblePoints(), function (_, p) {\n      var pointCoord = parseInt(rotated ? p.vy : p.vx);\n      if (!cat[pointCoord]) {\n        cat[pointCoord] = p;\n      } else {\n        Array.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p];\n      }\n    });\n    return cat;\n  },\n  _createErrorBarGroup: function (animationEnabled) {\n    var errorBarOptions = this._options.valueErrorBar;\n    var settings;\n    if (this.areErrorBarsVisible()) {\n      settings = {\n        class: \"dxc-error-bars\",\n        stroke: errorBarOptions.color,\n        \"stroke-width\": errorBarOptions.lineWidth,\n        opacity: animationEnabled ? .001 : errorBarOptions.opacity || 1,\n        \"stroke-linecap\": \"square\",\n        sharp: true,\n        \"clip-path\": this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID\n      };\n      this._createGroup(\"_errorBarGroup\", this, this._group, settings);\n    }\n  },\n  _setGroupsSettings: function (animationEnabled) {\n    this._setMarkerGroupSettings();\n    this._setLabelGroupSettings(animationEnabled);\n    this._createErrorBarGroup(animationEnabled);\n  },\n  _getCreatingPointOptions: function () {\n    var defaultPointOptions;\n    var creatingPointOptions = this._predefinedPointOptions;\n    var normalStyle;\n    if (!creatingPointOptions) {\n      defaultPointOptions = this._getPointOptions();\n      this._predefinedPointOptions = creatingPointOptions = _extend(true, {\n        styles: {}\n      }, defaultPointOptions);\n      normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};\n      creatingPointOptions.styles = creatingPointOptions.styles || {};\n      creatingPointOptions.styles.normal = {\n        \"stroke-width\": normalStyle[\"stroke-width\"],\n        r: normalStyle.r,\n        opacity: normalStyle.opacity\n      };\n    }\n    return creatingPointOptions;\n  },\n  _getPointOptions: function () {\n    return this._parsePointOptions(this._preparePointOptions(), this._options.label);\n  },\n  _getOptionsForPoint: function () {\n    return this._options.point;\n  },\n  _parsePointStyle: function (style, defaultColor, defaultBorderColor, defaultSize) {\n    var border = style.border || {};\n    var sizeValue = void 0 !== style.size ? style.size : defaultSize;\n    return {\n      fill: style.color || defaultColor,\n      stroke: border.color || defaultBorderColor,\n      \"stroke-width\": border.visible ? border.width : 0,\n      r: sizeValue / 2 + (border.visible && 0 !== sizeValue ? ~~(border.width / 2) || 0 : 0)\n    };\n  },\n  _createPointStyles: function (pointOptions) {\n    var mainPointColor = pointOptions.color || this._options.mainSeriesColor;\n    var containerColor = this._options.containerBackgroundColor;\n    var normalStyle = this._parsePointStyle(pointOptions, mainPointColor, mainPointColor);\n    normalStyle.visibility = pointOptions.visible ? \"visible\" : \"hidden\";\n    return {\n      normal: normalStyle,\n      hover: this._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor, pointOptions.size),\n      selection: this._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor, pointOptions.size)\n    };\n  },\n  _checkData: function (data, skippedFields, fieldsToCheck) {\n    fieldsToCheck = fieldsToCheck || {\n      value: this.getValueFields()[0]\n    };\n    fieldsToCheck.argument = this.getArgumentField();\n    return checkFields(data, fieldsToCheck, skippedFields || {}) && data.value === data.value;\n  },\n  getArgumentRangeInitialValue() {\n    var points = this.getPoints();\n    if (this.useAggregation() && points.length) {\n      var _points$0$aggregation, _points$aggregationIn;\n      return {\n        min: null === (_points$0$aggregation = points[0].aggregationInfo) || void 0 === _points$0$aggregation ? void 0 : _points$0$aggregation.intervalStart,\n        max: null === (_points$aggregationIn = points[points.length - 1].aggregationInfo) || void 0 === _points$aggregationIn ? void 0 : _points$aggregationIn.intervalEnd\n      };\n    }\n    return;\n  },\n  getValueRangeInitialValue: function () {\n    return;\n  },\n  _getRangeData: function () {\n    return rangeCalculator.getRangeData(this);\n  },\n  _getPointDataSelector: function () {\n    var valueField = this.getValueFields()[0];\n    var argumentField = this.getArgumentField();\n    var tagField = this.getTagField();\n    var areErrorBarsVisible = this.areErrorBarsVisible();\n    var lowValueField;\n    var highValueField;\n    if (areErrorBarsVisible) {\n      var errorBarOptions = this._options.valueErrorBar;\n      lowValueField = errorBarOptions.lowValueField || LOW_ERROR;\n      highValueField = errorBarOptions.highValueField || HIGH_ERROR;\n    }\n    return data => {\n      var pointData = {\n        value: this._processEmptyValue(data[valueField]),\n        argument: data[argumentField],\n        tag: data[tagField],\n        data: data\n      };\n      if (areErrorBarsVisible) {\n        pointData.lowError = data[lowValueField];\n        pointData.highError = data[highValueField];\n      }\n      return pointData;\n    };\n  },\n  _errorBarsEnabled: function () {\n    return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME;\n  },\n  _drawPoint: function (options) {\n    var point = options.point;\n    if (point.isInVisibleArea()) {\n      point.clearVisibility();\n      point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);\n      this._drawnPoints.push(point);\n    } else {\n      point.setInvisibility();\n    }\n  },\n  _animateComplete: function () {\n    var animationSettings = {\n      duration: this._defaultDuration\n    };\n    this._labelsGroup && this._labelsGroup.animate({\n      opacity: 1\n    }, animationSettings);\n    this._errorBarGroup && this._errorBarGroup.animate({\n      opacity: this._options.valueErrorBar.opacity || 1\n    }, animationSettings);\n  },\n  _animate: function () {\n    var that = this;\n    var lastPointIndex = that._drawnPoints.length - 1;\n    _each(that._drawnPoints || [], function (i, p) {\n      p.animate(i === lastPointIndex ? function () {\n        that._animateComplete();\n      } : void 0, {\n        translateX: p.x,\n        translateY: p.y\n      });\n    });\n  },\n  _getIntervalCenter(intervalStart, intervalEnd) {\n    var argAxis = this.getArgumentAxis();\n    var axisOptions = argAxis.getOptions();\n    if (argAxis.aggregatedPointBetweenTicks()) {\n      return intervalStart;\n    }\n    return \"discrete\" !== axisOptions.type ? argAxis.getVisualRangeCenter({\n      minVisible: intervalStart,\n      maxVisible: intervalEnd\n    }, true) : intervalStart;\n  },\n  _defaultAggregator: \"avg\",\n  _aggregators: {\n    avg(_ref2, series) {\n      var {\n        data: data,\n        intervalStart: intervalStart,\n        intervalEnd: intervalEnd\n      } = _ref2;\n      if (!data.length) {\n        return;\n      }\n      var valueField = series.getValueFields()[0];\n      var aggregationResult = data.reduce((result, item) => {\n        var value = item[valueField];\n        if (_isDefined(value)) {\n          result[0] += value;\n          result[1]++;\n        } else if (null === value) {\n          result[2]++;\n        }\n        return result;\n      }, [0, 0, 0]);\n      return calculateAvgErrorBars({\n        [valueField]: aggregationResult[2] === data.length ? null : aggregationResult[0] / aggregationResult[1],\n        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\n      }, data, series);\n    },\n    sum(_ref3, series) {\n      var {\n        intervalStart: intervalStart,\n        intervalEnd: intervalEnd,\n        data: data\n      } = _ref3;\n      if (!data.length) {\n        return;\n      }\n      var valueField = series.getValueFields()[0];\n      var aggregationResult = data.reduce((result, item) => {\n        var value = item[valueField];\n        if (void 0 !== value) {\n          result[0] += value;\n        }\n        if (null === value) {\n          result[1]++;\n        } else if (void 0 === value) {\n          result[2]++;\n        }\n        return result;\n      }, [0, 0, 0]);\n      var value = aggregationResult[0];\n      if (aggregationResult[1] === data.length) {\n        value = null;\n      }\n      if (aggregationResult[2] === data.length) {\n        return;\n      }\n      return calculateSumErrorBars({\n        [valueField]: value,\n        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\n      }, data, series);\n    },\n    count(_ref4, series) {\n      var {\n        data: data,\n        intervalStart: intervalStart,\n        intervalEnd: intervalEnd\n      } = _ref4;\n      var valueField = series.getValueFields()[0];\n      return {\n        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd),\n        [valueField]: data.filter(i => void 0 !== i[valueField]).length\n      };\n    },\n    min: getMinMaxAggregator((a, b) => a < b),\n    max: getMinMaxAggregator((a, b) => a > b)\n  },\n  _endUpdateData: function () {\n    delete this._predefinedPointOptions;\n  },\n  getArgumentField: function () {\n    return this._options.argumentField || \"arg\";\n  },\n  getValueFields: function () {\n    var options = this._options;\n    var errorBarsOptions = options.valueErrorBar;\n    var valueFields = [options.valueField || \"val\"];\n    var lowValueField;\n    var highValueField;\n    if (errorBarsOptions) {\n      lowValueField = errorBarsOptions.lowValueField;\n      highValueField = errorBarsOptions.highValueField;\n      _isString(lowValueField) && valueFields.push(lowValueField);\n      _isString(highValueField) && valueFields.push(highValueField);\n    }\n    return valueFields;\n  },\n  _calculateErrorBars: function (data) {\n    if (!this.areErrorBarsVisible()) {\n      return;\n    }\n    var options = this._options;\n    var errorBarsOptions = options.valueErrorBar;\n    var errorBarType = _normalizeEnum(errorBarsOptions.type);\n    var floatErrorValue = parseFloat(errorBarsOptions.value);\n    var valueField = this.getValueFields()[0];\n    var value;\n    var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n    var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n    var valueArray;\n    var valueArrayLength;\n    var meanValue;\n    var processDataItem;\n    var addSubError = function (_i, item) {\n      value = item.value;\n      item.lowError = value - floatErrorValue;\n      item.highError = value + floatErrorValue;\n    };\n    switch (errorBarType) {\n      case FIXED:\n        processDataItem = addSubError;\n        break;\n      case PERCENT:\n        processDataItem = function (_, item) {\n          value = item.value;\n          var error = value * floatErrorValue / 100;\n          item.lowError = value - error;\n          item.highError = value + error;\n        };\n        break;\n      case UNDEFINED:\n        processDataItem = function (_, item) {\n          item.lowError = item.data[lowValueField];\n          item.highError = item.data[highValueField];\n        };\n        break;\n      default:\n        valueArray = _map(data, function (item) {\n          return _isDefined(item.data[valueField]) ? item.data[valueField] : null;\n        });\n        valueArrayLength = valueArray.length;\n        floatErrorValue = floatErrorValue || 1;\n        switch (errorBarType) {\n          case VARIANCE:\n            floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;\n            processDataItem = addSubError;\n            break;\n          case STANDARD_DEVIATION:\n            meanValue = sum(valueArray) / valueArrayLength;\n            floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;\n            processDataItem = function (_, item) {\n              item.lowError = meanValue - floatErrorValue;\n              item.highError = meanValue + floatErrorValue;\n            };\n            break;\n          case STANDARD_ERROR:\n            floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;\n            processDataItem = addSubError;\n        }\n    }\n    processDataItem && _each(data, processDataItem);\n  },\n  _patchMarginOptions: function (options) {\n    var pointOptions = this._getCreatingPointOptions();\n    var styles = pointOptions.styles;\n    var maxSize = [styles.normal, styles.hover, styles.selection].reduce(function (max, style) {\n      return _max(max, 2 * style.r + style[\"stroke-width\"]);\n    }, 0);\n    options.size = pointOptions.visible ? maxSize : 0;\n    options.sizePointNormalState = pointOptions.visible ? 2 * styles.normal.r + styles.normal[\"stroke-width\"] : 2;\n    return options;\n  },\n  usePointsToDefineAutoHiding: () => true\n};\nchart = _extend({}, baseScatterMethods, {\n  drawTrackers: function () {\n    var that = this;\n    var trackers;\n    var trackersGroup;\n    var segments = that._segments || [];\n    var rotated = that._options.rotated;\n    if (!that.isVisible()) {\n      return;\n    }\n    if (segments.length) {\n      trackers = that._trackers = that._trackers || [];\n      trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({\n        fill: \"gray\",\n        opacity: .001,\n        stroke: \"gray\",\n        class: \"dxc-trackers\"\n      })).attr({\n        \"clip-path\": this._paneClipRectID || null\n      }).append(that._group);\n      _each(segments, function (i, segment) {\n        if (!trackers[i]) {\n          trackers[i] = that._drawTrackerElement(segment).data({\n            \"chart-data-series\": that\n          }).append(trackersGroup);\n        } else {\n          that._updateTrackerElement(segment, trackers[i]);\n        }\n      });\n    }\n    that._trackersTranslator = that.groupPointsByCoords(rotated);\n  },\n  _checkAxisVisibleAreaCoord(isArgument, coord) {\n    var axis = isArgument ? this.getArgumentAxis() : this.getValueAxis();\n    var visibleArea = axis.getVisibleArea();\n    return _isDefined(coord) && visibleArea[0] <= coord && visibleArea[1] >= coord;\n  },\n  checkSeriesViewportCoord(axis, coord) {\n    return this.getPoints().length && this.isVisible();\n  },\n  getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord = null;\n    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var points = this.getVisiblePoints();\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0;\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n    return oppositeCoord;\n  },\n  _getNearestPoints: (point, nextPoint) => [point, nextPoint],\n  _getBezierPoints: () => [],\n  _getNearestPointsByCoord(coord, isArgument) {\n    var that = this;\n    var rotated = that.getOptions().rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var allPoints = that.getPoints();\n    var bezierPoints = that._getBezierPoints();\n    var nearestPoints = [];\n    if (allPoints.length > 1) {\n      allPoints.forEach((point, i) => {\n        var nextPoint = allPoints[i + 1];\n        if (nextPoint && (point[coordName] <= coord && nextPoint[coordName] >= coord || point[coordName] >= coord && nextPoint[coordName] <= coord)) {\n          nearestPoints.push(that._getNearestPoints(point, nextPoint, bezierPoints));\n        }\n      });\n    } else {\n      nearestPoints.push([allPoints[0], allPoints[0]]);\n    }\n    return nearestPoints;\n  },\n  getNeighborPoint: function (x, y) {\n    var pCoord = this._options.rotated ? y : x;\n    var nCoord = pCoord;\n    var cat = this._trackersTranslator;\n    var point = null;\n    var minDistance;\n    var oppositeCoord = this._options.rotated ? x : y;\n    var oppositeCoordName = this._options.rotated ? \"vx\" : \"vy\";\n    if (this.isVisible() && cat) {\n      point = cat[pCoord];\n      do {\n        point = cat[nCoord] || cat[pCoord];\n        pCoord--;\n        nCoord++;\n      } while ((pCoord >= 0 || nCoord < cat.length) && !point);\n      if (Array.isArray(point)) {\n        minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);\n        _each(point, function (i, p) {\n          var distance = _abs(p[oppositeCoordName] - oppositeCoord);\n          if (minDistance >= distance) {\n            minDistance = distance;\n            point = p;\n          }\n        });\n      }\n    }\n    return point;\n  },\n  _applyVisibleArea: function () {\n    var rotated = this._options.rotated;\n    var visibleX = (rotated ? this.getValueAxis() : this.getArgumentAxis()).getVisibleArea();\n    var visibleY = (rotated ? this.getArgumentAxis() : this.getValueAxis()).getVisibleArea();\n    this._visibleArea = {\n      minX: visibleX[0],\n      maxX: visibleX[1],\n      minY: visibleY[0],\n      maxY: visibleY[1]\n    };\n  },\n  getPointCenterByArg(arg) {\n    var point = this.getPointsByArg(arg)[0];\n    return point ? point.getCenterCoord() : void 0;\n  }\n});\npolar = _extend({}, baseScatterMethods, {\n  drawTrackers: function () {\n    chart.drawTrackers.call(this);\n    var cat = this._trackersTranslator;\n    var index;\n    if (!this.isVisible()) {\n      return;\n    }\n    _each(cat, function (i, category) {\n      if (category) {\n        index = i;\n        return false;\n      }\n    });\n    cat[index + 360] = cat[index];\n  },\n  getNeighborPoint: function (x, y) {\n    var pos = convertXYToPolar(this.getValueAxis().getCenter(), x, y);\n    return chart.getNeighborPoint.call(this, pos.phi, pos.r);\n  },\n  _applyVisibleArea: function () {\n    var canvas = this.getValueAxis().getCanvas();\n    this._visibleArea = {\n      minX: canvas.left,\n      maxX: canvas.width - canvas.right,\n      minY: canvas.top,\n      maxY: canvas.height - canvas.bottom\n    };\n  },\n  getSeriesPairCoord(params, isArgument) {\n    var coords = null;\n    var paramName = isArgument ? \"argument\" : \"radius\";\n    var points = this.getVisiblePoints();\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpPoint = _isDefined(p[paramName]) && _isDefined(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? {\n        x: p.x,\n        y: p.y\n      } : void 0;\n      if (_isDefined(tmpPoint)) {\n        coords = tmpPoint;\n        break;\n      }\n    }\n    return coords;\n  }\n});\nexport { chart, polar };","map":{"version":3,"names":["extend","_extend","each","_each","rangeCalculator","isDefined","_isDefined","isString","_isString","map","_map","normalizeEnum","_normalizeEnum","convertXYToPolar","noop","_noop","math","Math","_abs","abs","_sqrt","sqrt","_max","max","DEFAULT_TRACKER_WIDTH","DEFAULT_DURATION","HIGH_ERROR","LOW_ERROR","VARIANCE","STANDARD_DEVIATION","STANDARD_ERROR","PERCENT","FIXED","UNDEFINED","DISCRETE","LOGARITHMIC","DATETIME","chart","polar","sum","array","result","_","value","isErrorBarTypeCorrect","type","includes","variance","expectedValue","length","calculateAvgErrorBars","data","series","errorBarsOptions","getOptions","valueErrorBar","valueField","getValueFields","lowValueField","highValueField","areErrorBarsVisible","fusionData","reduce","item","calculateSumErrorBars","getMinMaxAggregator","compare","_ref","intervalStart","intervalEnd","targetData","getArgumentField","_getIntervalCenter","checkFields","fieldsToCheck","skippedFields","allFieldsIsValid","field","isArgument","selector","baseScatterMethods","_defaultDuration","_defaultTrackerWidth","_applyStyle","_updateOptions","_parseStyle","_prepareSegment","_drawSegment","_appendInGroup","_group","append","_extGroups","seriesGroup","_createLegendState","styleOptions","defaultColor","fill","color","hatching","direction","_applyElementsClipRect","settings","_paneClipRectID","_applyMarkerClipRect","_forceClipping","_createGroup","groupName","parent","target","group","_renderer","g","attr","_applyClearingSettings","opacity","scale","_options","rotated","translateX","translateY","_createGroups","_setMarkerGroupSettings","_createPointStyles","_getMarkerGroupOptions","normal","class","_markersGroup","getVisibleArea","_visibleArea","errorBarOptions","_errorBarsEnabled","displayMode","groupPointsByCoords","cat","getVisiblePoints","p","pointCoord","parseInt","vy","vx","Array","isArray","push","_createErrorBarGroup","animationEnabled","stroke","lineWidth","sharp","_widePaneClipRectID","_setGroupsSettings","_setLabelGroupSettings","_getCreatingPointOptions","defaultPointOptions","creatingPointOptions","_predefinedPointOptions","normalStyle","_getPointOptions","styles","r","_parsePointOptions","_preparePointOptions","label","_getOptionsForPoint","point","_parsePointStyle","style","defaultBorderColor","defaultSize","border","sizeValue","size","visible","width","pointOptions","mainPointColor","mainSeriesColor","containerColor","containerBackgroundColor","visibility","hover","hoverStyle","selection","selectionStyle","_checkData","argument","getArgumentRangeInitialValue","points","getPoints","useAggregation","_points$0$aggregation","_points$aggregationIn","min","aggregationInfo","getValueRangeInitialValue","_getRangeData","getRangeData","_getPointDataSelector","argumentField","tagField","getTagField","pointData","_processEmptyValue","tag","lowError","highError","valueAxisType","valueType","_drawPoint","options","isInVisibleArea","clearVisibility","draw","groups","hasAnimation","firstDrawing","_drawnPoints","setInvisibility","_animateComplete","animationSettings","duration","_labelsGroup","animate","_errorBarGroup","_animate","that","lastPointIndex","i","x","y","argAxis","getArgumentAxis","axisOptions","aggregatedPointBetweenTicks","getVisualRangeCenter","minVisible","maxVisible","_defaultAggregator","_aggregators","avg","_ref2","aggregationResult","_ref3","count","_ref4","filter","a","b","_endUpdateData","valueFields","_calculateErrorBars","errorBarType","floatErrorValue","parseFloat","valueArray","valueArrayLength","meanValue","processDataItem","addSubError","_i","error","_patchMarginOptions","maxSize","sizePointNormalState","usePointsToDefineAutoHiding","drawTrackers","trackers","trackersGroup","segments","_segments","isVisible","_trackers","_trackersGroup","segment","_drawTrackerElement","_updateTrackerElement","_trackersTranslator","_checkAxisVisibleAreaCoord","coord","axis","getValueAxis","visibleArea","checkSeriesViewportCoord","getSeriesPairCoord","oppositeCoord","isOpposite","coordName","oppositeCoordName","tmpCoord","_getNearestPoints","nextPoint","_getBezierPoints","_getNearestPointsByCoord","allPoints","bezierPoints","nearestPoints","forEach","getNeighborPoint","pCoord","nCoord","minDistance","distance","_applyVisibleArea","visibleX","visibleY","minX","maxX","minY","maxY","getPointCenterByArg","arg","getPointsByArg","getCenterCoord","call","index","category","pos","getCenter","phi","canvas","getCanvas","left","right","top","height","bottom","params","coords","paramName","tmpPoint","valueOf"],"sources":["C:/Users/User/vue-chart/node_modules/devextreme/esm/viz/series/scatter_series.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/viz/series/scatter_series.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    extend as _extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    each as _each\r\n} from \"../../core/utils/iterator\";\r\nimport rangeCalculator from \"./helpers/range_data_calculator\";\r\nimport {\r\n    isDefined as _isDefined,\r\n    isString as _isString\r\n} from \"../../core/utils/type\";\r\nimport {\r\n    map as _map,\r\n    normalizeEnum as _normalizeEnum,\r\n    convertXYToPolar\r\n} from \"../core/utils\";\r\nimport {\r\n    noop as _noop\r\n} from \"../../core/utils/common\";\r\nvar math = Math;\r\nvar _abs = math.abs;\r\nvar _sqrt = math.sqrt;\r\nvar _max = math.max;\r\nvar DEFAULT_TRACKER_WIDTH = 12;\r\nvar DEFAULT_DURATION = 400;\r\nvar HIGH_ERROR = \"highError\";\r\nvar LOW_ERROR = \"lowError\";\r\nvar VARIANCE = \"variance\";\r\nvar STANDARD_DEVIATION = \"stddeviation\";\r\nvar STANDARD_ERROR = \"stderror\";\r\nvar PERCENT = \"percent\";\r\nvar FIXED = \"fixed\";\r\nvar UNDEFINED = \"undefined\";\r\nvar DISCRETE = \"discrete\";\r\nvar LOGARITHMIC = \"logarithmic\";\r\nvar DATETIME = \"datetime\";\r\nvar chart = {};\r\nvar polar = {};\r\n\r\nfunction sum(array) {\r\n    var result = 0;\r\n    _each(array, (function(_, value) {\r\n        result += value\r\n    }));\r\n    return result\r\n}\r\n\r\nfunction isErrorBarTypeCorrect(type) {\r\n    return [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR].includes(type)\r\n}\r\n\r\nfunction variance(array, expectedValue) {\r\n    return sum(_map(array, (function(value) {\r\n        return (value - expectedValue) * (value - expectedValue)\r\n    }))) / array.length\r\n}\r\n\r\nfunction calculateAvgErrorBars(result, data, series) {\r\n    var errorBarsOptions = series.getOptions().valueErrorBar;\r\n    var valueField = series.getValueFields()[0];\r\n    var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\r\n    var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\r\n    if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\r\n        var fusionData = data.reduce((function(result, item) {\r\n            if (_isDefined(item[lowValueField])) {\r\n                result[0] += item[valueField] - item[lowValueField];\r\n                result[1]++\r\n            }\r\n            if (_isDefined(item[highValueField])) {\r\n                result[2] += item[highValueField] - item[valueField];\r\n                result[3]++\r\n            }\r\n            return result\r\n        }), [0, 0, 0, 0]);\r\n        if (fusionData[1]) {\r\n            result[lowValueField] = result[valueField] - fusionData[0] / fusionData[1]\r\n        }\r\n        if (fusionData[2]) {\r\n            result[highValueField] = result[valueField] + fusionData[2] / fusionData[3]\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nfunction calculateSumErrorBars(result, data, series) {\r\n    var errorBarsOptions = series.getOptions().valueErrorBar;\r\n    var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\r\n    var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\r\n    if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\r\n        result[lowValueField] = 0;\r\n        result[highValueField] = 0;\r\n        result = data.reduce((function(result, item) {\r\n            result[lowValueField] += item[lowValueField];\r\n            result[highValueField] += item[highValueField];\r\n            return result\r\n        }), result)\r\n    }\r\n    return result\r\n}\r\n\r\nfunction getMinMaxAggregator(compare) {\r\n    return (_ref, series) => {\r\n        var {\r\n            intervalStart: intervalStart,\r\n            intervalEnd: intervalEnd,\r\n            data: data\r\n        } = _ref;\r\n        var valueField = series.getValueFields()[0];\r\n        var targetData = data[0];\r\n        targetData = data.reduce((result, item) => {\r\n            var value = item[valueField];\r\n            if (null === result[valueField]) {\r\n                result = item\r\n            }\r\n            if (null !== value && compare(value, result[valueField])) {\r\n                return item\r\n            }\r\n            return result\r\n        }, targetData);\r\n        return _extend({}, targetData, {\r\n            [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\r\n        })\r\n    }\r\n}\r\n\r\nfunction checkFields(data, fieldsToCheck, skippedFields) {\r\n    var allFieldsIsValid = true;\r\n    for (var field in fieldsToCheck) {\r\n        var isArgument = \"argument\" === field;\r\n        if (isArgument || \"size\" === field ? !_isDefined(data[field]) : void 0 === data[field]) {\r\n            var selector = fieldsToCheck[field];\r\n            if (!isArgument) {\r\n                skippedFields[selector] = (skippedFields[selector] || 0) + 1\r\n            }\r\n            allFieldsIsValid = false\r\n        }\r\n    }\r\n    return allFieldsIsValid\r\n}\r\nvar baseScatterMethods = {\r\n    _defaultDuration: DEFAULT_DURATION,\r\n    _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,\r\n    _applyStyle: _noop,\r\n    _updateOptions: _noop,\r\n    _parseStyle: _noop,\r\n    _prepareSegment: _noop,\r\n    _drawSegment: _noop,\r\n    _appendInGroup: function() {\r\n        this._group.append(this._extGroups.seriesGroup)\r\n    },\r\n    _createLegendState: function(styleOptions, defaultColor) {\r\n        return {\r\n            fill: styleOptions.color || defaultColor,\r\n            hatching: styleOptions.hatching ? _extend({}, styleOptions.hatching, {\r\n                direction: \"right\"\r\n            }) : void 0\r\n        }\r\n    },\r\n    _applyElementsClipRect: function(settings) {\r\n        settings[\"clip-path\"] = this._paneClipRectID\r\n    },\r\n    _applyMarkerClipRect: function(settings) {\r\n        settings[\"clip-path\"] = this._forceClipping ? this._paneClipRectID : null\r\n    },\r\n    _createGroup: function(groupName, parent, target, settings) {\r\n        var group = parent[groupName] = parent[groupName] || this._renderer.g();\r\n        target && group.append(target);\r\n        settings && group.attr(settings)\r\n    },\r\n    _applyClearingSettings: function(settings) {\r\n        settings.opacity = null;\r\n        settings.scale = null;\r\n        if (this._options.rotated) {\r\n            settings.translateX = null\r\n        } else {\r\n            settings.translateY = null\r\n        }\r\n    },\r\n    _createGroups: function() {\r\n        this._createGroup(\"_markersGroup\", this, this._group);\r\n        this._createGroup(\"_labelsGroup\", this)\r\n    },\r\n    _setMarkerGroupSettings: function() {\r\n        var settings = this._createPointStyles(this._getMarkerGroupOptions()).normal;\r\n        settings.class = \"dxc-markers\";\r\n        settings.opacity = 1;\r\n        this._applyMarkerClipRect(settings);\r\n        this._markersGroup.attr(settings)\r\n    },\r\n    getVisibleArea: function() {\r\n        return this._visibleArea\r\n    },\r\n    areErrorBarsVisible: function() {\r\n        var errorBarOptions = this._options.valueErrorBar;\r\n        return errorBarOptions && this._errorBarsEnabled() && \"none\" !== errorBarOptions.displayMode && (isErrorBarTypeCorrect(_normalizeEnum(errorBarOptions.type)) || _isDefined(errorBarOptions.lowValueField) || _isDefined(errorBarOptions.highValueField))\r\n    },\r\n    groupPointsByCoords(rotated) {\r\n        var cat = [];\r\n        _each(this.getVisiblePoints(), (function(_, p) {\r\n            var pointCoord = parseInt(rotated ? p.vy : p.vx);\r\n            if (!cat[pointCoord]) {\r\n                cat[pointCoord] = p\r\n            } else {\r\n                Array.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p]\r\n            }\r\n        }));\r\n        return cat\r\n    },\r\n    _createErrorBarGroup: function(animationEnabled) {\r\n        var errorBarOptions = this._options.valueErrorBar;\r\n        var settings;\r\n        if (this.areErrorBarsVisible()) {\r\n            settings = {\r\n                class: \"dxc-error-bars\",\r\n                stroke: errorBarOptions.color,\r\n                \"stroke-width\": errorBarOptions.lineWidth,\r\n                opacity: animationEnabled ? .001 : errorBarOptions.opacity || 1,\r\n                \"stroke-linecap\": \"square\",\r\n                sharp: true,\r\n                \"clip-path\": this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID\r\n            };\r\n            this._createGroup(\"_errorBarGroup\", this, this._group, settings)\r\n        }\r\n    },\r\n    _setGroupsSettings: function(animationEnabled) {\r\n        this._setMarkerGroupSettings();\r\n        this._setLabelGroupSettings(animationEnabled);\r\n        this._createErrorBarGroup(animationEnabled)\r\n    },\r\n    _getCreatingPointOptions: function() {\r\n        var defaultPointOptions;\r\n        var creatingPointOptions = this._predefinedPointOptions;\r\n        var normalStyle;\r\n        if (!creatingPointOptions) {\r\n            defaultPointOptions = this._getPointOptions();\r\n            this._predefinedPointOptions = creatingPointOptions = _extend(true, {\r\n                styles: {}\r\n            }, defaultPointOptions);\r\n            normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};\r\n            creatingPointOptions.styles = creatingPointOptions.styles || {};\r\n            creatingPointOptions.styles.normal = {\r\n                \"stroke-width\": normalStyle[\"stroke-width\"],\r\n                r: normalStyle.r,\r\n                opacity: normalStyle.opacity\r\n            }\r\n        }\r\n        return creatingPointOptions\r\n    },\r\n    _getPointOptions: function() {\r\n        return this._parsePointOptions(this._preparePointOptions(), this._options.label)\r\n    },\r\n    _getOptionsForPoint: function() {\r\n        return this._options.point\r\n    },\r\n    _parsePointStyle: function(style, defaultColor, defaultBorderColor, defaultSize) {\r\n        var border = style.border || {};\r\n        var sizeValue = void 0 !== style.size ? style.size : defaultSize;\r\n        return {\r\n            fill: style.color || defaultColor,\r\n            stroke: border.color || defaultBorderColor,\r\n            \"stroke-width\": border.visible ? border.width : 0,\r\n            r: sizeValue / 2 + (border.visible && 0 !== sizeValue ? ~~(border.width / 2) || 0 : 0)\r\n        }\r\n    },\r\n    _createPointStyles: function(pointOptions) {\r\n        var mainPointColor = pointOptions.color || this._options.mainSeriesColor;\r\n        var containerColor = this._options.containerBackgroundColor;\r\n        var normalStyle = this._parsePointStyle(pointOptions, mainPointColor, mainPointColor);\r\n        normalStyle.visibility = pointOptions.visible ? \"visible\" : \"hidden\";\r\n        return {\r\n            normal: normalStyle,\r\n            hover: this._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor, pointOptions.size),\r\n            selection: this._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor, pointOptions.size)\r\n        }\r\n    },\r\n    _checkData: function(data, skippedFields, fieldsToCheck) {\r\n        fieldsToCheck = fieldsToCheck || {\r\n            value: this.getValueFields()[0]\r\n        };\r\n        fieldsToCheck.argument = this.getArgumentField();\r\n        return checkFields(data, fieldsToCheck, skippedFields || {}) && data.value === data.value\r\n    },\r\n    getArgumentRangeInitialValue() {\r\n        var points = this.getPoints();\r\n        if (this.useAggregation() && points.length) {\r\n            var _points$0$aggregation, _points$aggregationIn;\r\n            return {\r\n                min: null === (_points$0$aggregation = points[0].aggregationInfo) || void 0 === _points$0$aggregation ? void 0 : _points$0$aggregation.intervalStart,\r\n                max: null === (_points$aggregationIn = points[points.length - 1].aggregationInfo) || void 0 === _points$aggregationIn ? void 0 : _points$aggregationIn.intervalEnd\r\n            }\r\n        }\r\n        return\r\n    },\r\n    getValueRangeInitialValue: function() {\r\n        return\r\n    },\r\n    _getRangeData: function() {\r\n        return rangeCalculator.getRangeData(this)\r\n    },\r\n    _getPointDataSelector: function() {\r\n        var valueField = this.getValueFields()[0];\r\n        var argumentField = this.getArgumentField();\r\n        var tagField = this.getTagField();\r\n        var areErrorBarsVisible = this.areErrorBarsVisible();\r\n        var lowValueField;\r\n        var highValueField;\r\n        if (areErrorBarsVisible) {\r\n            var errorBarOptions = this._options.valueErrorBar;\r\n            lowValueField = errorBarOptions.lowValueField || LOW_ERROR;\r\n            highValueField = errorBarOptions.highValueField || HIGH_ERROR\r\n        }\r\n        return data => {\r\n            var pointData = {\r\n                value: this._processEmptyValue(data[valueField]),\r\n                argument: data[argumentField],\r\n                tag: data[tagField],\r\n                data: data\r\n            };\r\n            if (areErrorBarsVisible) {\r\n                pointData.lowError = data[lowValueField];\r\n                pointData.highError = data[highValueField]\r\n            }\r\n            return pointData\r\n        }\r\n    },\r\n    _errorBarsEnabled: function() {\r\n        return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME\r\n    },\r\n    _drawPoint: function(options) {\r\n        var point = options.point;\r\n        if (point.isInVisibleArea()) {\r\n            point.clearVisibility();\r\n            point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);\r\n            this._drawnPoints.push(point)\r\n        } else {\r\n            point.setInvisibility()\r\n        }\r\n    },\r\n    _animateComplete: function() {\r\n        var animationSettings = {\r\n            duration: this._defaultDuration\r\n        };\r\n        this._labelsGroup && this._labelsGroup.animate({\r\n            opacity: 1\r\n        }, animationSettings);\r\n        this._errorBarGroup && this._errorBarGroup.animate({\r\n            opacity: this._options.valueErrorBar.opacity || 1\r\n        }, animationSettings)\r\n    },\r\n    _animate: function() {\r\n        var that = this;\r\n        var lastPointIndex = that._drawnPoints.length - 1;\r\n        _each(that._drawnPoints || [], (function(i, p) {\r\n            p.animate(i === lastPointIndex ? function() {\r\n                that._animateComplete()\r\n            } : void 0, {\r\n                translateX: p.x,\r\n                translateY: p.y\r\n            })\r\n        }))\r\n    },\r\n    _getIntervalCenter(intervalStart, intervalEnd) {\r\n        var argAxis = this.getArgumentAxis();\r\n        var axisOptions = argAxis.getOptions();\r\n        if (argAxis.aggregatedPointBetweenTicks()) {\r\n            return intervalStart\r\n        }\r\n        return \"discrete\" !== axisOptions.type ? argAxis.getVisualRangeCenter({\r\n            minVisible: intervalStart,\r\n            maxVisible: intervalEnd\r\n        }, true) : intervalStart\r\n    },\r\n    _defaultAggregator: \"avg\",\r\n    _aggregators: {\r\n        avg(_ref2, series) {\r\n            var {\r\n                data: data,\r\n                intervalStart: intervalStart,\r\n                intervalEnd: intervalEnd\r\n            } = _ref2;\r\n            if (!data.length) {\r\n                return\r\n            }\r\n            var valueField = series.getValueFields()[0];\r\n            var aggregationResult = data.reduce((result, item) => {\r\n                var value = item[valueField];\r\n                if (_isDefined(value)) {\r\n                    result[0] += value;\r\n                    result[1]++\r\n                } else if (null === value) {\r\n                    result[2]++\r\n                }\r\n                return result\r\n            }, [0, 0, 0]);\r\n            return calculateAvgErrorBars({\r\n                [valueField]: aggregationResult[2] === data.length ? null : aggregationResult[0] / aggregationResult[1],\r\n                [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\r\n            }, data, series)\r\n        },\r\n        sum(_ref3, series) {\r\n            var {\r\n                intervalStart: intervalStart,\r\n                intervalEnd: intervalEnd,\r\n                data: data\r\n            } = _ref3;\r\n            if (!data.length) {\r\n                return\r\n            }\r\n            var valueField = series.getValueFields()[0];\r\n            var aggregationResult = data.reduce((result, item) => {\r\n                var value = item[valueField];\r\n                if (void 0 !== value) {\r\n                    result[0] += value\r\n                }\r\n                if (null === value) {\r\n                    result[1]++\r\n                } else if (void 0 === value) {\r\n                    result[2]++\r\n                }\r\n                return result\r\n            }, [0, 0, 0]);\r\n            var value = aggregationResult[0];\r\n            if (aggregationResult[1] === data.length) {\r\n                value = null\r\n            }\r\n            if (aggregationResult[2] === data.length) {\r\n                return\r\n            }\r\n            return calculateSumErrorBars({\r\n                [valueField]: value,\r\n                [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)\r\n            }, data, series)\r\n        },\r\n        count(_ref4, series) {\r\n            var {\r\n                data: data,\r\n                intervalStart: intervalStart,\r\n                intervalEnd: intervalEnd\r\n            } = _ref4;\r\n            var valueField = series.getValueFields()[0];\r\n            return {\r\n                [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd),\r\n                [valueField]: data.filter(i => void 0 !== i[valueField]).length\r\n            }\r\n        },\r\n        min: getMinMaxAggregator((a, b) => a < b),\r\n        max: getMinMaxAggregator((a, b) => a > b)\r\n    },\r\n    _endUpdateData: function() {\r\n        delete this._predefinedPointOptions\r\n    },\r\n    getArgumentField: function() {\r\n        return this._options.argumentField || \"arg\"\r\n    },\r\n    getValueFields: function() {\r\n        var options = this._options;\r\n        var errorBarsOptions = options.valueErrorBar;\r\n        var valueFields = [options.valueField || \"val\"];\r\n        var lowValueField;\r\n        var highValueField;\r\n        if (errorBarsOptions) {\r\n            lowValueField = errorBarsOptions.lowValueField;\r\n            highValueField = errorBarsOptions.highValueField;\r\n            _isString(lowValueField) && valueFields.push(lowValueField);\r\n            _isString(highValueField) && valueFields.push(highValueField)\r\n        }\r\n        return valueFields\r\n    },\r\n    _calculateErrorBars: function(data) {\r\n        if (!this.areErrorBarsVisible()) {\r\n            return\r\n        }\r\n        var options = this._options;\r\n        var errorBarsOptions = options.valueErrorBar;\r\n        var errorBarType = _normalizeEnum(errorBarsOptions.type);\r\n        var floatErrorValue = parseFloat(errorBarsOptions.value);\r\n        var valueField = this.getValueFields()[0];\r\n        var value;\r\n        var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\r\n        var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\r\n        var valueArray;\r\n        var valueArrayLength;\r\n        var meanValue;\r\n        var processDataItem;\r\n        var addSubError = function(_i, item) {\r\n            value = item.value;\r\n            item.lowError = value - floatErrorValue;\r\n            item.highError = value + floatErrorValue\r\n        };\r\n        switch (errorBarType) {\r\n            case FIXED:\r\n                processDataItem = addSubError;\r\n                break;\r\n            case PERCENT:\r\n                processDataItem = function(_, item) {\r\n                    value = item.value;\r\n                    var error = value * floatErrorValue / 100;\r\n                    item.lowError = value - error;\r\n                    item.highError = value + error\r\n                };\r\n                break;\r\n            case UNDEFINED:\r\n                processDataItem = function(_, item) {\r\n                    item.lowError = item.data[lowValueField];\r\n                    item.highError = item.data[highValueField]\r\n                };\r\n                break;\r\n            default:\r\n                valueArray = _map(data, (function(item) {\r\n                    return _isDefined(item.data[valueField]) ? item.data[valueField] : null\r\n                }));\r\n                valueArrayLength = valueArray.length;\r\n                floatErrorValue = floatErrorValue || 1;\r\n                switch (errorBarType) {\r\n                    case VARIANCE:\r\n                        floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;\r\n                        processDataItem = addSubError;\r\n                        break;\r\n                    case STANDARD_DEVIATION:\r\n                        meanValue = sum(valueArray) / valueArrayLength;\r\n                        floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;\r\n                        processDataItem = function(_, item) {\r\n                            item.lowError = meanValue - floatErrorValue;\r\n                            item.highError = meanValue + floatErrorValue\r\n                        };\r\n                        break;\r\n                    case STANDARD_ERROR:\r\n                        floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;\r\n                        processDataItem = addSubError\r\n                }\r\n        }\r\n        processDataItem && _each(data, processDataItem)\r\n    },\r\n    _patchMarginOptions: function(options) {\r\n        var pointOptions = this._getCreatingPointOptions();\r\n        var styles = pointOptions.styles;\r\n        var maxSize = [styles.normal, styles.hover, styles.selection].reduce((function(max, style) {\r\n            return _max(max, 2 * style.r + style[\"stroke-width\"])\r\n        }), 0);\r\n        options.size = pointOptions.visible ? maxSize : 0;\r\n        options.sizePointNormalState = pointOptions.visible ? 2 * styles.normal.r + styles.normal[\"stroke-width\"] : 2;\r\n        return options\r\n    },\r\n    usePointsToDefineAutoHiding: () => true\r\n};\r\nchart = _extend({}, baseScatterMethods, {\r\n    drawTrackers: function() {\r\n        var that = this;\r\n        var trackers;\r\n        var trackersGroup;\r\n        var segments = that._segments || [];\r\n        var rotated = that._options.rotated;\r\n        if (!that.isVisible()) {\r\n            return\r\n        }\r\n        if (segments.length) {\r\n            trackers = that._trackers = that._trackers || [];\r\n            trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({\r\n                fill: \"gray\",\r\n                opacity: .001,\r\n                stroke: \"gray\",\r\n                class: \"dxc-trackers\"\r\n            })).attr({\r\n                \"clip-path\": this._paneClipRectID || null\r\n            }).append(that._group);\r\n            _each(segments, (function(i, segment) {\r\n                if (!trackers[i]) {\r\n                    trackers[i] = that._drawTrackerElement(segment).data({\r\n                        \"chart-data-series\": that\r\n                    }).append(trackersGroup)\r\n                } else {\r\n                    that._updateTrackerElement(segment, trackers[i])\r\n                }\r\n            }))\r\n        }\r\n        that._trackersTranslator = that.groupPointsByCoords(rotated)\r\n    },\r\n    _checkAxisVisibleAreaCoord(isArgument, coord) {\r\n        var axis = isArgument ? this.getArgumentAxis() : this.getValueAxis();\r\n        var visibleArea = axis.getVisibleArea();\r\n        return _isDefined(coord) && visibleArea[0] <= coord && visibleArea[1] >= coord\r\n    },\r\n    checkSeriesViewportCoord(axis, coord) {\r\n        return this.getPoints().length && this.isVisible()\r\n    },\r\n    getSeriesPairCoord(coord, isArgument) {\r\n        var oppositeCoord = null;\r\n        var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\r\n        var coordName = !isOpposite ? \"vx\" : \"vy\";\r\n        var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\r\n        var points = this.getVisiblePoints();\r\n        for (var i = 0; i < points.length; i++) {\r\n            var p = points[i];\r\n            var tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0;\r\n            if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    },\r\n    _getNearestPoints: (point, nextPoint) => [point, nextPoint],\r\n    _getBezierPoints: () => [],\r\n    _getNearestPointsByCoord(coord, isArgument) {\r\n        var that = this;\r\n        var rotated = that.getOptions().rotated;\r\n        var isOpposite = !isArgument && !rotated || isArgument && rotated;\r\n        var coordName = isOpposite ? \"vy\" : \"vx\";\r\n        var allPoints = that.getPoints();\r\n        var bezierPoints = that._getBezierPoints();\r\n        var nearestPoints = [];\r\n        if (allPoints.length > 1) {\r\n            allPoints.forEach((point, i) => {\r\n                var nextPoint = allPoints[i + 1];\r\n                if (nextPoint && (point[coordName] <= coord && nextPoint[coordName] >= coord || point[coordName] >= coord && nextPoint[coordName] <= coord)) {\r\n                    nearestPoints.push(that._getNearestPoints(point, nextPoint, bezierPoints))\r\n                }\r\n            })\r\n        } else {\r\n            nearestPoints.push([allPoints[0], allPoints[0]])\r\n        }\r\n        return nearestPoints\r\n    },\r\n    getNeighborPoint: function(x, y) {\r\n        var pCoord = this._options.rotated ? y : x;\r\n        var nCoord = pCoord;\r\n        var cat = this._trackersTranslator;\r\n        var point = null;\r\n        var minDistance;\r\n        var oppositeCoord = this._options.rotated ? x : y;\r\n        var oppositeCoordName = this._options.rotated ? \"vx\" : \"vy\";\r\n        if (this.isVisible() && cat) {\r\n            point = cat[pCoord];\r\n            do {\r\n                point = cat[nCoord] || cat[pCoord];\r\n                pCoord--;\r\n                nCoord++\r\n            } while ((pCoord >= 0 || nCoord < cat.length) && !point);\r\n            if (Array.isArray(point)) {\r\n                minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);\r\n                _each(point, (function(i, p) {\r\n                    var distance = _abs(p[oppositeCoordName] - oppositeCoord);\r\n                    if (minDistance >= distance) {\r\n                        minDistance = distance;\r\n                        point = p\r\n                    }\r\n                }))\r\n            }\r\n        }\r\n        return point\r\n    },\r\n    _applyVisibleArea: function() {\r\n        var rotated = this._options.rotated;\r\n        var visibleX = (rotated ? this.getValueAxis() : this.getArgumentAxis()).getVisibleArea();\r\n        var visibleY = (rotated ? this.getArgumentAxis() : this.getValueAxis()).getVisibleArea();\r\n        this._visibleArea = {\r\n            minX: visibleX[0],\r\n            maxX: visibleX[1],\r\n            minY: visibleY[0],\r\n            maxY: visibleY[1]\r\n        }\r\n    },\r\n    getPointCenterByArg(arg) {\r\n        var point = this.getPointsByArg(arg)[0];\r\n        return point ? point.getCenterCoord() : void 0\r\n    }\r\n});\r\npolar = _extend({}, baseScatterMethods, {\r\n    drawTrackers: function() {\r\n        chart.drawTrackers.call(this);\r\n        var cat = this._trackersTranslator;\r\n        var index;\r\n        if (!this.isVisible()) {\r\n            return\r\n        }\r\n        _each(cat, (function(i, category) {\r\n            if (category) {\r\n                index = i;\r\n                return false\r\n            }\r\n        }));\r\n        cat[index + 360] = cat[index]\r\n    },\r\n    getNeighborPoint: function(x, y) {\r\n        var pos = convertXYToPolar(this.getValueAxis().getCenter(), x, y);\r\n        return chart.getNeighborPoint.call(this, pos.phi, pos.r)\r\n    },\r\n    _applyVisibleArea: function() {\r\n        var canvas = this.getValueAxis().getCanvas();\r\n        this._visibleArea = {\r\n            minX: canvas.left,\r\n            maxX: canvas.width - canvas.right,\r\n            minY: canvas.top,\r\n            maxY: canvas.height - canvas.bottom\r\n        }\r\n    },\r\n    getSeriesPairCoord(params, isArgument) {\r\n        var coords = null;\r\n        var paramName = isArgument ? \"argument\" : \"radius\";\r\n        var points = this.getVisiblePoints();\r\n        for (var i = 0; i < points.length; i++) {\r\n            var p = points[i];\r\n            var tmpPoint = _isDefined(p[paramName]) && _isDefined(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? {\r\n                x: p.x,\r\n                y: p.y\r\n            } : void 0;\r\n            if (_isDefined(tmpPoint)) {\r\n                coords = tmpPoint;\r\n                break\r\n            }\r\n        }\r\n        return coords\r\n    }\r\n});\r\nexport {\r\n    chart,\r\n    polar\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}