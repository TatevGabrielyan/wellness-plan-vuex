{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nexport default {\n  props: {\n    diameter: {\n      type: Number,\n      required: false,\n      default: 200\n    },\n    totalSteps: {\n      type: Number,\n      required: true,\n      default: 10\n    },\n    completedSteps: {\n      type: Number,\n      required: true,\n      default: 0\n    },\n    startColor: {\n      type: String,\n      required: false,\n      default: '#bbff42'\n    },\n    stopColor: {\n      type: String,\n      required: false,\n      default: '#429321'\n    },\n    strokeWidth: {\n      type: Number,\n      required: false,\n      default: 10\n    },\n    innerStrokeWidth: {\n      type: Number,\n      required: false,\n      default: 10\n    },\n    strokeLinecap: {\n      type: String,\n      required: false,\n      default: 'round'\n    },\n    animateSpeed: {\n      type: Number,\n      required: false,\n      default: 1000\n    },\n    innerStrokeColor: {\n      type: String,\n      required: false,\n      default: '#323232'\n    },\n    fps: {\n      type: Number,\n      required: false,\n      default: 60\n    },\n    timingFunc: {\n      type: String,\n      required: false,\n      default: 'linear'\n    },\n    isClockwise: {\n      type: Boolean,\n      required: false,\n      default: true\n    }\n  },\n  data() {\n    return {\n      gradient: {\n        fx: 0.99,\n        fy: 0.5,\n        cx: 0.5,\n        cy: 0.5,\n        r: 0.65\n      },\n      gradientAnimation: null,\n      currentAngle: 0,\n      strokeDashoffset: 0\n    };\n  },\n  computed: {\n    radius() {\n      return this.diameter / 2;\n    },\n    circumference() {\n      return Math.PI * this.innerCircleDiameter;\n    },\n    stepSize() {\n      if (this.totalSteps === 0) {\n        return 0;\n      }\n      return 100 / this.totalSteps;\n    },\n    finishedPercentage() {\n      return this.stepSize * this.completedSteps;\n    },\n    circleSlice() {\n      return 2 * Math.PI / this.totalSteps;\n    },\n    animateSlice() {\n      return this.circleSlice / this.totalPoints;\n    },\n    innerCircleDiameter() {\n      return this.diameter - this.innerStrokeWidth * 2;\n    },\n    innerCircleRadius() {\n      return this.innerCircleDiameter / 2;\n    },\n    totalPoints() {\n      return this.animateSpeed / this.animationIncrements;\n    },\n    animationIncrements() {\n      return 1000 / this.fps;\n    },\n    hasGradient() {\n      return this.startColor !== this.stopColor;\n    },\n    containerStyle() {\n      return {\n        height: `${this.diameter}px`,\n        width: `${this.diameter}px`\n      };\n    },\n    progressStyle() {\n      return {\n        height: `${this.diameter}px`,\n        width: `${this.diameter}px`,\n        strokeWidth: `${this.strokeWidth}px`,\n        strokeDashoffset: this.strokeDashoffset,\n        transition: `stroke-dashoffset ${this.animateSpeed}ms ${this.timingFunc}`\n      };\n    },\n    strokeStyle() {\n      return {\n        height: `${this.diameter}px`,\n        width: `${this.diameter}px`,\n        strokeWidth: `${this.innerStrokeWidth}px`\n      };\n    },\n    innerCircleStyle() {\n      return {\n        width: `${this.innerCircleDiameter}px`\n      };\n    }\n  },\n  methods: {\n    getStopPointsOfCircle(steps) {\n      const points = [];\n      for (let i = 0; i < steps; i++) {\n        const angle = this.circleSlice * i;\n        points.push(this.getPointOfCircle(angle));\n      }\n      return points;\n    },\n    getPointOfCircle(angle) {\n      const radius = 0.5;\n      const x = radius + radius * Math.cos(angle);\n      const y = radius + radius * Math.sin(angle);\n      return {\n        x,\n        y\n      };\n    },\n    gotoPoint() {\n      const point = this.getPointOfCircle(this.currentAngle);\n      if (point.x && point.y) {\n        this.gradient.fx = point.x;\n        this.gradient.fy = point.y;\n      }\n    },\n    direction() {\n      if (this.isClockwise) {\n        return 1;\n      }\n      return -1;\n    },\n    changeProgress({\n      isAnimate = true\n    }) {\n      this.strokeDashoffset = (100 - this.finishedPercentage) / 100 * this.circumference * this.direction();\n      if (this.gradientAnimation) {\n        clearInterval(this.gradientAnimation);\n      }\n      if (!isAnimate) {\n        this.gotoNextStep();\n        return;\n      }\n      const angleOffset = (this.completedSteps - 1) * this.circleSlice;\n      let i = (this.currentAngle - angleOffset) / this.animateSlice;\n      const incrementer = Math.abs(i - this.totalPoints) / this.totalPoints;\n      const isMoveForward = i < this.totalPoints;\n      this.gradientAnimation = setInterval(() => {\n        if (isMoveForward && i >= this.totalPoints || !isMoveForward && i < this.totalPoints) {\n          clearInterval(this.gradientAnimation);\n          return;\n        }\n        this.currentAngle = angleOffset + this.animateSlice * i;\n        this.gotoPoint();\n        i += isMoveForward ? incrementer : -incrementer;\n      }, this.animationIncrements);\n    },\n    gotoNextStep() {\n      this.currentAngle = this.completedSteps * this.circleSlice;\n      this.gotoPoint();\n    }\n  },\n  watch: {\n    totalSteps() {\n      this.changeProgress({\n        isAnimate: true\n      });\n    },\n    completedSteps() {\n      this.changeProgress({\n        isAnimate: true\n      });\n    },\n    diameter() {\n      this.changeProgress({\n        isAnimate: true\n      });\n    },\n    strokeWidth() {\n      this.changeProgress({\n        isAnimate: true\n      });\n    }\n  },\n  created() {\n    this.changeProgress({\n      isAnimate: false\n    });\n  }\n};","map":{"version":3,"mappings":"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","names":["props","diameter","type","Number","required","default","totalSteps","completedSteps","startColor","String","stopColor","strokeWidth","innerStrokeWidth","strokeLinecap","animateSpeed","innerStrokeColor","fps","timingFunc","isClockwise","Boolean","data","gradient","fx","fy","cx","cy","r","gradientAnimation","currentAngle","strokeDashoffset","computed","radius","circumference","Math","PI","innerCircleDiameter","stepSize","finishedPercentage","circleSlice","animateSlice","totalPoints","innerCircleRadius","animationIncrements","hasGradient","containerStyle","height","width","progressStyle","transition","strokeStyle","innerCircleStyle","methods","getStopPointsOfCircle","steps","points","i","angle","push","getPointOfCircle","x","cos","y","sin","gotoPoint","point","direction","changeProgress","isAnimate","clearInterval","gotoNextStep","angleOffset","incrementer","abs","isMoveForward","setInterval","watch","created"],"sourceRoot":"","sources":["C:\\Users\\User\\vue-chart\\node_modules\\vue-radial-progress\\src\\RadialProgressBar.vue"],"sourcesContent":["<template>\n  <div class=\"radial-progress-container\" :style=\"containerStyle\">\n    <div class=\"radial-progress-inner\" :style=\"innerCircleStyle\">\n      <slot></slot>\n    </div>\n    <svg class=\"radial-progress-bar\"\n         :width=\"diameter\"\n         :height=\"diameter\"\n         version=\"1.1\"\n         xmlns=\"http://www.w3.org/2000/svg\">\n      <defs>\n        <radialGradient :id=\"'radial-gradient' + _uid\"\n                        :fx=\"gradient.fx\"\n                        :fy=\"gradient.fy\"\n                        :cx=\"gradient.cx\"\n                        :cy=\"gradient.cy\"\n                        :r=\"gradient.r\">\n          <stop offset=\"30%\" :stop-color=\"startColor\"/>\n          <stop offset=\"100%\" :stop-color=\"stopColor\"/>\n        </radialGradient>\n      </defs>\n      <circle :r=\"innerCircleRadius\"\n              :cx=\"radius\"\n              :cy=\"radius\"\n              fill=\"transparent\"\n              :stroke=\"innerStrokeColor\"\n              :stroke-dasharray=\"circumference\"\n              stroke-dashoffset=\"0\"\n              :stroke-linecap=\"strokeLinecap\"\n              :style=\"strokeStyle\"></circle>\n      <circle :transform=\"'rotate(270, ' + radius + ',' + radius + ')'\"\n              :r=\"innerCircleRadius\"\n              :cx=\"radius\"\n              :cy=\"radius\"\n              fill=\"transparent\"\n              :stroke=\"'url(#radial-gradient' + _uid + ')'\"\n              :stroke-dasharray=\"circumference\"\n              :stroke-dashoffset=\"circumference\"\n              :stroke-linecap=\"strokeLinecap\"\n              :style=\"progressStyle\"></circle>\n    </svg>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    diameter: {\n      type: Number,\n      required: false,\n      default: 200\n    },\n    totalSteps: {\n      type: Number,\n      required: true,\n      default: 10\n    },\n    completedSteps: {\n      type: Number,\n      required: true,\n      default: 0\n    },\n    startColor: {\n      type: String,\n      required: false,\n      default: '#bbff42'\n    },\n    stopColor: {\n      type: String,\n      required: false,\n      default: '#429321'\n    },\n    strokeWidth: {\n      type: Number,\n      required: false,\n      default: 10\n    },\n    innerStrokeWidth: {\n      type: Number,\n      required: false,\n      default: 10\n    },\n    strokeLinecap: {\n      type: String,\n      required: false,\n      default: 'round'\n    },\n    animateSpeed: {\n      type: Number,\n      required: false,\n      default: 1000\n    },\n    innerStrokeColor: {\n      type: String,\n      required: false,\n      default: '#323232'\n    },\n    fps: {\n      type: Number,\n      required: false,\n      default: 60\n    },\n    timingFunc: {\n      type: String,\n      required: false,\n      default: 'linear'\n    },\n    isClockwise: {\n      type: Boolean,\n      required: false,\n      default: true\n    }\n  },\n\n  data () {\n    return {\n      gradient: {\n        fx: 0.99,\n        fy: 0.5,\n        cx: 0.5,\n        cy: 0.5,\n        r: 0.65\n      },\n      gradientAnimation: null,\n      currentAngle: 0,\n      strokeDashoffset: 0\n    }\n  },\n\n  computed: {\n    radius () {\n      return this.diameter / 2\n    },\n\n    circumference () {\n      return Math.PI * this.innerCircleDiameter\n    },\n\n    stepSize () {\n      if (this.totalSteps === 0) {\n        return 0\n      }\n\n      return 100 / this.totalSteps\n    },\n\n    finishedPercentage () {\n      return this.stepSize * this.completedSteps\n    },\n\n    circleSlice () {\n      return 2 * Math.PI / this.totalSteps\n    },\n\n    animateSlice () {\n      return this.circleSlice / this.totalPoints\n    },\n\n    innerCircleDiameter () {\n      return this.diameter - (this.innerStrokeWidth * 2)\n    },\n\n    innerCircleRadius () {\n      return this.innerCircleDiameter / 2\n    },\n\n    totalPoints () {\n      return this.animateSpeed / this.animationIncrements\n    },\n\n    animationIncrements () {\n      return 1000 / this.fps\n    },\n\n    hasGradient () {\n      return this.startColor !== this.stopColor\n    },\n\n    containerStyle () {\n      return {\n        height: `${this.diameter}px`,\n        width: `${this.diameter}px`\n      }\n    },\n\n    progressStyle () {\n      return {\n        height: `${this.diameter}px`,\n        width: `${this.diameter}px`,\n        strokeWidth: `${this.strokeWidth}px`,\n        strokeDashoffset: this.strokeDashoffset,\n        transition: `stroke-dashoffset ${this.animateSpeed}ms ${this.timingFunc}`\n      }\n    },\n\n    strokeStyle () {\n      return {\n        height: `${this.diameter}px`,\n        width: `${this.diameter}px`,\n        strokeWidth: `${this.innerStrokeWidth}px`\n      }\n    },\n\n    innerCircleStyle () {\n      return {\n        width: `${this.innerCircleDiameter}px`\n      }\n    },\n  },\n\n  methods: {\n    getStopPointsOfCircle (steps) {\n      const points = []\n\n      for (let i = 0; i < steps; i++) {\n        const angle = this.circleSlice * i\n        points.push(this.getPointOfCircle(angle))\n      }\n\n      return points\n    },\n\n    getPointOfCircle (angle) {\n      const radius = 0.5\n\n      const x = radius + (radius * Math.cos(angle))\n      const y = radius + (radius * Math.sin(angle))\n\n      return { x, y }\n    },\n\n    gotoPoint () {\n      const point = this.getPointOfCircle(this.currentAngle)\n\n      if (point.x && point.y) {\n        this.gradient.fx = point.x\n        this.gradient.fy = point.y\n      }\n    },\n\n    direction () {\n      if (this.isClockwise) {\n        return 1\n      }\n      return -1\n    },\n\n    changeProgress ({ isAnimate = true }) {\n      this.strokeDashoffset = ((100 - this.finishedPercentage) / 100) * this.circumference * this.direction()\n\n      if (this.gradientAnimation) {\n        clearInterval(this.gradientAnimation)\n      }\n\n      if (!isAnimate) {\n        this.gotoNextStep()\n        return\n      }\n\n      const angleOffset = (this.completedSteps - 1) * this.circleSlice\n      let i = (this.currentAngle - angleOffset) / this.animateSlice\n      const incrementer = Math.abs(i - this.totalPoints) / this.totalPoints\n      const isMoveForward = i < this.totalPoints\n\n      this.gradientAnimation = setInterval(() => {\n        if (isMoveForward && i >= this.totalPoints ||\n            !isMoveForward && i < this.totalPoints) {\n          clearInterval(this.gradientAnimation)\n          return\n        }\n\n        this.currentAngle = angleOffset + (this.animateSlice * i)\n        this.gotoPoint()\n\n        i += isMoveForward ? incrementer : -incrementer\n      }, this.animationIncrements)\n    },\n\n    gotoNextStep () {\n      this.currentAngle = this.completedSteps * this.circleSlice\n      this.gotoPoint()\n    }\n  },\n\n  watch: {\n    totalSteps () {\n      this.changeProgress({ isAnimate: true })\n    },\n\n    completedSteps () {\n      this.changeProgress({ isAnimate: true })\n    },\n\n    diameter () {\n      this.changeProgress({ isAnimate: true })\n    },\n\n    strokeWidth () {\n      this.changeProgress({ isAnimate: true })\n    }\n  },\n\n  created () {\n    this.changeProgress({ isAnimate: false })\n  }\n}\n</script>\n\n<style>\n.radial-progress-container {\n  position: relative;\n}\n\n.radial-progress-inner {\n  position: absolute;\n  top: 0; right: 0; bottom: 0; left: 0;\n  position: absolute;\n  border-radius: 50%;\n  margin: 0 auto;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n</style>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}