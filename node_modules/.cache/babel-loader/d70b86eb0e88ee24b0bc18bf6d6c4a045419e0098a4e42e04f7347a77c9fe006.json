{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * DevExtreme (esm/viz/components/data_validator.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined as _isDefined, isFunction as _isFunction, isString as _isString, isDate as _isDate, isNumeric as _isNumber, isObject as _isObject } from \"../../core/utils/type\";\nvar STRING = \"string\";\nvar NUMERIC = \"numeric\";\nvar DATETIME = \"datetime\";\nvar DISCRETE = \"discrete\";\nvar SEMIDISCRETE = \"semidiscrete\";\nvar CONTINUOUS = \"continuous\";\nvar LOGARITHMIC = \"logarithmic\";\nvar VALUE_TYPE = \"valueType\";\nvar ARGUMENT_TYPE = \"argumentType\";\nimport { extend } from \"../../core/utils/extend\";\nimport { enumParser } from \"../core/utils\";\nvar axisTypeParser = enumParser([STRING, NUMERIC, DATETIME]);\nimport { getParser as _getParser } from \"./parse_utils\";\nvar _isArray = Array.isArray;\nfunction groupingValues(data, others, valueField, index) {\n  if (index >= 0) {\n    data.slice(index).forEach(function (cell) {\n      if (_isDefined(cell[valueField])) {\n        others[valueField] += cell[valueField];\n        cell[valueField] = void 0;\n      }\n    });\n  }\n}\nfunction processGroups(groups) {\n  groups.forEach(function (group) {\n    group.valueType = group.valueAxisType = null;\n    group.series.forEach(function (series) {\n      series.updateDataType({});\n    });\n    group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE);\n  });\n}\nfunction sortValues(data, asc, selector) {\n  var func = asc ? function (a, b) {\n    return a - b;\n  } : function (a, b) {\n    return b - a;\n  };\n  data.sort(function (a, b) {\n    var valA = selector(a);\n    var valB = selector(b);\n    var aa = _isDefined(valA) ? 1 : 0;\n    var bb = _isDefined(valB) ? 1 : 0;\n    return aa && bb ? func(valA, valB) : func(aa, bb);\n  });\n  return data;\n}\nfunction resetArgumentAxes(axes) {\n  axes && axes.forEach(function (axis) {\n    axis.resetTypes(ARGUMENT_TYPE);\n  });\n}\nfunction parseCategories(categories, parser) {\n  var newArray = [];\n  categories.forEach(function (category) {\n    var parsedCategory = parser(category);\n    void 0 !== parsedCategory && newArray.push(parsedCategory);\n  });\n  return newArray;\n}\nfunction parseAxisCategories(groupsData, parsers) {\n  var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;\n  groupsData.groups.forEach(function (valueGroup, i) {\n    var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;\n    if (categories) {\n      valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1]);\n    }\n  });\n  if (argumentCategories) {\n    groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0]);\n  }\n}\nfunction eigen(x) {\n  return x;\n}\nfunction getType(unit, type) {\n  var result = type;\n  if (type === STRING || _isString(unit)) {\n    result = STRING;\n  } else if (type === DATETIME || _isDate(unit)) {\n    result = DATETIME;\n  } else if (_isNumber(unit)) {\n    result = NUMERIC;\n  }\n  return result;\n}\nfunction correctAxisType(type, axisType, hasCategories, incidentOccurred) {\n  if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {\n    incidentOccurred(\"E2002\");\n  }\n  return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS;\n}\nfunction validUnit(unit, field, incidentOccurred) {\n  if (unit) {\n    incidentOccurred(!_isNumber(unit) && !_isDate(unit) && !_isString(unit) ? \"E2003\" : \"E2004\", [field]);\n  }\n}\nfunction createParserUnit(type, axisType, incidentOccurred) {\n  var parser = type ? _getParser(type) : eigen;\n  var filterInfinity = axisType !== DISCRETE ? function (x) {\n    return isFinite(x) || void 0 === x ? x : null;\n  } : eigen;\n  return function (unit, field) {\n    var parseUnit = filterInfinity(parser(unit));\n    if (void 0 === parseUnit) {\n      validUnit(unit, field, incidentOccurred);\n    }\n    return parseUnit;\n  };\n}\nfunction prepareParsers(groupsData, incidentOccurred) {\n  var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);\n  var sizeParser;\n  var valueParser;\n  var categoryParsers = [argumentParser];\n  var cache = {};\n  var list = [];\n  groupsData.groups.forEach(function (group, groupIndex) {\n    group.series.forEach(function (series) {\n      valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);\n      sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);\n      cache[series.getArgumentField()] = argumentParser;\n      series.getValueFields().forEach(function (field) {\n        categoryParsers[groupIndex + 1] = valueParser;\n        cache[field] = valueParser;\n      });\n      if (series.getSizeField()) {\n        cache[series.getSizeField()] = sizeParser;\n      }\n    });\n  });\n  for (var field in cache) {\n    list.push([field, cache[field]]);\n  }\n  list.length && parseAxisCategories(groupsData, categoryParsers);\n  return list;\n}\nfunction getParsedCell(cell, parsers) {\n  var i;\n  var ii = parsers.length;\n  var obj = extend({}, cell);\n  var field;\n  var value;\n  for (i = 0; i < ii; ++i) {\n    field = parsers[i][0];\n    value = cell[field];\n    obj[field] = parsers[i][1](value, field);\n  }\n  return obj;\n}\nfunction parse(data, parsers) {\n  var parsedData = [];\n  var i;\n  var ii = data.length;\n  parsedData.length = ii;\n  for (i = 0; i < ii; ++i) {\n    parsedData[i] = getParsedCell(data[i], parsers);\n  }\n  return parsedData;\n}\nfunction findIndexByThreshold(data, valueField, threshold) {\n  var i;\n  var ii = data.length;\n  var value;\n  for (i = 0; i < ii; ++i) {\n    value = data[i][valueField];\n    if (_isDefined(value) && threshold > value) {\n      break;\n    }\n  }\n  return i;\n}\nfunction groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {\n  smallValuesGrouping = smallValuesGrouping || {};\n  var mode = smallValuesGrouping.mode;\n  var others = {};\n  if (!mode || \"none\" === mode) {\n    return;\n  }\n  others[argumentField] = String(smallValuesGrouping.groupName || \"others\");\n  others[valueField] = 0;\n  var data = sortValues(originalData.slice(), false, function (a) {\n    return a[valueField];\n  });\n  groupingValues(data, others, valueField, \"smallValueThreshold\" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);\n  others[valueField] && originalData.push(others);\n}\nfunction groupPieData(data, groupsData) {\n  var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];\n  var isPie = firstSeries && (\"pie\" === firstSeries.type || \"doughnut\" === firstSeries.type || \"donut\" === firstSeries.type);\n  if (!isPie) {\n    return;\n  }\n  groupsData.groups.forEach(function (group) {\n    group.series.forEach(function (series) {\n      groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping);\n    });\n  });\n}\nfunction addUniqueItemToCollection(item, collection, itemsHash) {\n  if (!itemsHash[item]) {\n    collection.push(item);\n    itemsHash[item] = true;\n  }\n}\nfunction getUniqueArgumentFields(groupsData) {\n  var uniqueArgumentFields = [];\n  var hash = {};\n  groupsData.groups.forEach(function (group) {\n    group.series.forEach(function (series) {\n      addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash);\n    });\n  });\n  return uniqueArgumentFields;\n}\nfunction sort(a, b) {\n  var result = a - b;\n  if (isNaN(result)) {\n    if (!_isDefined(a)) {\n      return 1;\n    }\n    if (!_isDefined(b)) {\n      return -1;\n    }\n    return 0;\n  }\n  return result;\n}\nfunction sortByArgument(data, argumentField) {\n  return data.slice().sort(function (a, b) {\n    return sort(a[argumentField], b[argumentField]);\n  });\n}\nfunction sortByCallback(data, callback) {\n  return data.slice().sort(callback);\n}\nfunction checkValueTypeOfGroup(group, cell) {\n  group.series.forEach(function (series) {\n    series.getValueFields().forEach(function (field) {\n      group.valueType = getType(cell[field], group.valueType);\n    });\n  });\n  return group.valueType;\n}\nfunction getSortByCategories(categories) {\n  var hash = {};\n  categories.forEach(function (value, i) {\n    hash[value] = i;\n  });\n  return function (data, argumentField) {\n    return sortValues(data.slice(), true, function (a) {\n      return hash[a[argumentField]];\n    });\n  };\n}\nfunction sortData(data, groupsData, options, uniqueArgumentFields) {\n  var dataByArguments = {};\n  var isDiscrete = groupsData.argumentAxisType === DISCRETE;\n  var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;\n  var sortFunction = function (data) {\n    return data;\n  };\n  var sortingMethodOption = options.sortingMethod;\n  var reSortCategories;\n  if (!userCategories && _isFunction(sortingMethodOption)) {\n    data = sortByCallback(data, sortingMethodOption);\n  }\n  if (isDiscrete) {\n    groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories);\n  }\n  if (userCategories || !_isFunction(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {\n    sortFunction = getSortByCategories(groupsData.categories);\n  } else if (true === sortingMethodOption && groupsData.argumentType !== STRING) {\n    sortFunction = sortByArgument;\n    reSortCategories = isDiscrete;\n  }\n  uniqueArgumentFields.forEach(function (field) {\n    dataByArguments[field] = sortFunction(data, field);\n  });\n  if (reSortCategories) {\n    groupsData.categories = groupsData.categories.sort(sort);\n  }\n  return dataByArguments;\n}\nfunction checkItemExistence(collection, item) {\n  return -1 === collection.map(function (collectionItem) {\n    return collectionItem.valueOf();\n  }).indexOf(item.valueOf());\n}\nfunction getCategories(data, uniqueArgumentFields, userCategories) {\n  var categories = userCategories ? userCategories.slice() : [];\n  uniqueArgumentFields.forEach(function (field) {\n    data.forEach(function (item) {\n      var dataItem = item[field];\n      _isDefined(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem);\n    });\n  });\n  return categories;\n}\nfunction checkArgumentTypeOfGroup(series, cell, groupsData) {\n  series.forEach(function (currentSeries) {\n    groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType);\n  });\n  return groupsData.argumentType;\n}\nfunction checkType(data, groupsData, checkTypeForAllData) {\n  var groupsWithUndefinedValueType = [];\n  var groupsWithUndefinedArgumentType = [];\n  var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);\n  var groupsIndexes;\n  groupsData.groups.forEach(function (group) {\n    if (!group.series.length) {\n      return;\n    }\n    var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);\n    group.valueType = valueTypeGroup;\n    groupsData.argumentType = argumentTypeGroup;\n    !valueTypeGroup && groupsWithUndefinedValueType.push(group);\n    !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group);\n  });\n  if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {\n    groupsIndexes = groupsWithUndefinedValueType.map(function (_, index) {\n      return index;\n    });\n    data.some(function (cell) {\n      var defineArg;\n      groupsWithUndefinedValueType.forEach(function (group, groupIndex) {\n        if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {\n          groupsIndexes.splice(groupIndex, 1);\n        }\n      });\n      if (!defineArg) {\n        groupsWithUndefinedArgumentType.forEach(function (group) {\n          defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData);\n        });\n      }\n      if (!checkTypeForAllData && defineArg && 0 === groupsIndexes.length) {\n        return true;\n      }\n    });\n  }\n}\nfunction checkAxisType(groupsData, incidentOccurred) {\n  var argumentOptions = groupsData.argumentOptions || {};\n  var userArgumentCategories = argumentOptions && argumentOptions.categories || [];\n  var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);\n  groupsData.groups.forEach(function (group) {\n    var valueOptions = group.valueOptions || {};\n    var valueCategories = valueOptions.categories || [];\n    var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);\n    group.series.forEach(function (series) {\n      var optionsSeries = {};\n      optionsSeries.argumentAxisType = argumentAxisType;\n      optionsSeries.valueAxisType = valueAxisType;\n      groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;\n      group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;\n      optionsSeries.argumentType = groupsData.argumentType;\n      optionsSeries.valueType = group.valueType;\n      optionsSeries.showZero = valueOptions.showZero;\n      series.updateDataType(optionsSeries);\n    });\n    group.valueAxisType = group.valueAxisType || valueAxisType;\n    if (group.valueAxis) {\n      group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);\n      group.valueAxis.validate();\n    }\n  });\n  groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;\n  if (groupsData.argumentAxes) {\n    groupsData.argumentAxes.forEach(function (axis) {\n      axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);\n      axis.validate();\n    });\n  }\n}\nfunction verifyData(source, incidentOccurred) {\n  var data = [];\n  var sourceIsDefined = _isDefined(source);\n  var hasError = sourceIsDefined && !_isArray(source);\n  var i;\n  var ii;\n  var k;\n  var item;\n  if (sourceIsDefined && !hasError) {\n    for (i = 0, ii = source.length, k = 0; i < ii; ++i) {\n      item = source[i];\n      if (_isObject(item)) {\n        data[k++] = item;\n      } else if (item) {\n        hasError = true;\n      }\n    }\n  }\n  if (hasError) {\n    incidentOccurred(\"E2001\");\n  }\n  return data;\n}\nexport function validateData(data, groupsData, incidentOccurred, options) {\n  data = verifyData(data, incidentOccurred);\n  groupsData.argumentType = groupsData.argumentAxisType = null;\n  processGroups(groupsData.groups);\n  resetArgumentAxes(groupsData.argumentAxes);\n  checkType(data, groupsData, options.checkTypeForAllData);\n  checkAxisType(groupsData, incidentOccurred);\n  if (options.convertToAxisDataType) {\n    data = parse(data, prepareParsers(groupsData, incidentOccurred));\n  }\n  groupPieData(data, groupsData);\n  var dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));\n  return dataByArgumentFields;\n}","map":{"version":3,"names":["isDefined","_isDefined","isFunction","_isFunction","isString","_isString","isDate","_isDate","isNumeric","_isNumber","isObject","_isObject","STRING","NUMERIC","DATETIME","DISCRETE","SEMIDISCRETE","CONTINUOUS","LOGARITHMIC","VALUE_TYPE","ARGUMENT_TYPE","extend","enumParser","axisTypeParser","getParser","_getParser","_isArray","Array","isArray","groupingValues","data","others","valueField","index","slice","forEach","cell","processGroups","groups","group","valueType","valueAxisType","series","updateDataType","valueAxis","resetTypes","sortValues","asc","selector","func","a","b","sort","valA","valB","aa","bb","resetArgumentAxes","axes","axis","parseCategories","categories","parser","newArray","category","parsedCategory","push","parseAxisCategories","groupsData","parsers","argumentCategories","argumentOptions","valueGroup","i","valueOptions","eigen","x","getType","unit","type","result","correctAxisType","axisType","hasCategories","incidentOccurred","validUnit","field","createParserUnit","filterInfinity","isFinite","parseUnit","prepareParsers","argumentParser","argumentType","argumentAxisType","sizeParser","valueParser","categoryParsers","cache","list","groupIndex","getArgumentField","getValueFields","getSizeField","length","getParsedCell","ii","obj","value","parse","parsedData","findIndexByThreshold","threshold","groupMinSlices","originalData","argumentField","smallValuesGrouping","mode","String","groupName","topCount","groupPieData","firstSeries","isPie","getOptions","addUniqueItemToCollection","item","collection","itemsHash","getUniqueArgumentFields","uniqueArgumentFields","hash","isNaN","sortByArgument","sortByCallback","callback","checkValueTypeOfGroup","getSortByCategories","sortData","options","dataByArguments","isDiscrete","userCategories","sortFunction","sortingMethodOption","sortingMethod","reSortCategories","getCategories","_skipArgumentSorting","checkItemExistence","map","collectionItem","valueOf","indexOf","dataItem","checkArgumentTypeOfGroup","currentSeries","checkType","checkTypeForAllData","groupsWithUndefinedValueType","groupsWithUndefinedArgumentType","argumentTypeGroup","groupsIndexes","valueTypeGroup","_","some","defineArg","splice","checkAxisType","userArgumentCategories","valueCategories","optionsSeries","showZero","setTypes","validate","argumentAxes","verifyData","source","sourceIsDefined","hasError","k","validateData","convertToAxisDataType","dataByArgumentFields"],"sources":["C:/Users/User/vue-chart/node_modules/devextreme/esm/viz/components/data_validator.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/viz/components/data_validator.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    isDefined as _isDefined,\r\n    isFunction as _isFunction,\r\n    isString as _isString,\r\n    isDate as _isDate,\r\n    isNumeric as _isNumber,\r\n    isObject as _isObject\r\n} from \"../../core/utils/type\";\r\nvar STRING = \"string\";\r\nvar NUMERIC = \"numeric\";\r\nvar DATETIME = \"datetime\";\r\nvar DISCRETE = \"discrete\";\r\nvar SEMIDISCRETE = \"semidiscrete\";\r\nvar CONTINUOUS = \"continuous\";\r\nvar LOGARITHMIC = \"logarithmic\";\r\nvar VALUE_TYPE = \"valueType\";\r\nvar ARGUMENT_TYPE = \"argumentType\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    enumParser\r\n} from \"../core/utils\";\r\nvar axisTypeParser = enumParser([STRING, NUMERIC, DATETIME]);\r\nimport {\r\n    getParser as _getParser\r\n} from \"./parse_utils\";\r\nvar _isArray = Array.isArray;\r\n\r\nfunction groupingValues(data, others, valueField, index) {\r\n    if (index >= 0) {\r\n        data.slice(index).forEach((function(cell) {\r\n            if (_isDefined(cell[valueField])) {\r\n                others[valueField] += cell[valueField];\r\n                cell[valueField] = void 0\r\n            }\r\n        }))\r\n    }\r\n}\r\n\r\nfunction processGroups(groups) {\r\n    groups.forEach((function(group) {\r\n        group.valueType = group.valueAxisType = null;\r\n        group.series.forEach((function(series) {\r\n            series.updateDataType({})\r\n        }));\r\n        group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE)\r\n    }))\r\n}\r\n\r\nfunction sortValues(data, asc, selector) {\r\n    var func = asc ? function(a, b) {\r\n        return a - b\r\n    } : function(a, b) {\r\n        return b - a\r\n    };\r\n    data.sort((function(a, b) {\r\n        var valA = selector(a);\r\n        var valB = selector(b);\r\n        var aa = _isDefined(valA) ? 1 : 0;\r\n        var bb = _isDefined(valB) ? 1 : 0;\r\n        return aa && bb ? func(valA, valB) : func(aa, bb)\r\n    }));\r\n    return data\r\n}\r\n\r\nfunction resetArgumentAxes(axes) {\r\n    axes && axes.forEach((function(axis) {\r\n        axis.resetTypes(ARGUMENT_TYPE)\r\n    }))\r\n}\r\n\r\nfunction parseCategories(categories, parser) {\r\n    var newArray = [];\r\n    categories.forEach((function(category) {\r\n        var parsedCategory = parser(category);\r\n        void 0 !== parsedCategory && newArray.push(parsedCategory)\r\n    }));\r\n    return newArray\r\n}\r\n\r\nfunction parseAxisCategories(groupsData, parsers) {\r\n    var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;\r\n    groupsData.groups.forEach((function(valueGroup, i) {\r\n        var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;\r\n        if (categories) {\r\n            valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1])\r\n        }\r\n    }));\r\n    if (argumentCategories) {\r\n        groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0])\r\n    }\r\n}\r\n\r\nfunction eigen(x) {\r\n    return x\r\n}\r\n\r\nfunction getType(unit, type) {\r\n    var result = type;\r\n    if (type === STRING || _isString(unit)) {\r\n        result = STRING\r\n    } else if (type === DATETIME || _isDate(unit)) {\r\n        result = DATETIME\r\n    } else if (_isNumber(unit)) {\r\n        result = NUMERIC\r\n    }\r\n    return result\r\n}\r\n\r\nfunction correctAxisType(type, axisType, hasCategories, incidentOccurred) {\r\n    if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {\r\n        incidentOccurred(\"E2002\")\r\n    }\r\n    return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS\r\n}\r\n\r\nfunction validUnit(unit, field, incidentOccurred) {\r\n    if (unit) {\r\n        incidentOccurred(!_isNumber(unit) && !_isDate(unit) && !_isString(unit) ? \"E2003\" : \"E2004\", [field])\r\n    }\r\n}\r\n\r\nfunction createParserUnit(type, axisType, incidentOccurred) {\r\n    var parser = type ? _getParser(type) : eigen;\r\n    var filterInfinity = axisType !== DISCRETE ? function(x) {\r\n        return isFinite(x) || void 0 === x ? x : null\r\n    } : eigen;\r\n    return function(unit, field) {\r\n        var parseUnit = filterInfinity(parser(unit));\r\n        if (void 0 === parseUnit) {\r\n            validUnit(unit, field, incidentOccurred)\r\n        }\r\n        return parseUnit\r\n    }\r\n}\r\n\r\nfunction prepareParsers(groupsData, incidentOccurred) {\r\n    var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);\r\n    var sizeParser;\r\n    var valueParser;\r\n    var categoryParsers = [argumentParser];\r\n    var cache = {};\r\n    var list = [];\r\n    groupsData.groups.forEach((function(group, groupIndex) {\r\n        group.series.forEach((function(series) {\r\n            valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);\r\n            sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);\r\n            cache[series.getArgumentField()] = argumentParser;\r\n            series.getValueFields().forEach((function(field) {\r\n                categoryParsers[groupIndex + 1] = valueParser;\r\n                cache[field] = valueParser\r\n            }));\r\n            if (series.getSizeField()) {\r\n                cache[series.getSizeField()] = sizeParser\r\n            }\r\n        }))\r\n    }));\r\n    for (var field in cache) {\r\n        list.push([field, cache[field]])\r\n    }\r\n    list.length && parseAxisCategories(groupsData, categoryParsers);\r\n    return list\r\n}\r\n\r\nfunction getParsedCell(cell, parsers) {\r\n    var i;\r\n    var ii = parsers.length;\r\n    var obj = extend({}, cell);\r\n    var field;\r\n    var value;\r\n    for (i = 0; i < ii; ++i) {\r\n        field = parsers[i][0];\r\n        value = cell[field];\r\n        obj[field] = parsers[i][1](value, field)\r\n    }\r\n    return obj\r\n}\r\n\r\nfunction parse(data, parsers) {\r\n    var parsedData = [];\r\n    var i;\r\n    var ii = data.length;\r\n    parsedData.length = ii;\r\n    for (i = 0; i < ii; ++i) {\r\n        parsedData[i] = getParsedCell(data[i], parsers)\r\n    }\r\n    return parsedData\r\n}\r\n\r\nfunction findIndexByThreshold(data, valueField, threshold) {\r\n    var i;\r\n    var ii = data.length;\r\n    var value;\r\n    for (i = 0; i < ii; ++i) {\r\n        value = data[i][valueField];\r\n        if (_isDefined(value) && threshold > value) {\r\n            break\r\n        }\r\n    }\r\n    return i\r\n}\r\n\r\nfunction groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {\r\n    smallValuesGrouping = smallValuesGrouping || {};\r\n    var mode = smallValuesGrouping.mode;\r\n    var others = {};\r\n    if (!mode || \"none\" === mode) {\r\n        return\r\n    }\r\n    others[argumentField] = String(smallValuesGrouping.groupName || \"others\");\r\n    others[valueField] = 0;\r\n    var data = sortValues(originalData.slice(), false, (function(a) {\r\n        return a[valueField]\r\n    }));\r\n    groupingValues(data, others, valueField, \"smallValueThreshold\" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);\r\n    others[valueField] && originalData.push(others)\r\n}\r\n\r\nfunction groupPieData(data, groupsData) {\r\n    var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];\r\n    var isPie = firstSeries && (\"pie\" === firstSeries.type || \"doughnut\" === firstSeries.type || \"donut\" === firstSeries.type);\r\n    if (!isPie) {\r\n        return\r\n    }\r\n    groupsData.groups.forEach((function(group) {\r\n        group.series.forEach((function(series) {\r\n            groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping)\r\n        }))\r\n    }))\r\n}\r\n\r\nfunction addUniqueItemToCollection(item, collection, itemsHash) {\r\n    if (!itemsHash[item]) {\r\n        collection.push(item);\r\n        itemsHash[item] = true\r\n    }\r\n}\r\n\r\nfunction getUniqueArgumentFields(groupsData) {\r\n    var uniqueArgumentFields = [];\r\n    var hash = {};\r\n    groupsData.groups.forEach((function(group) {\r\n        group.series.forEach((function(series) {\r\n            addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash)\r\n        }))\r\n    }));\r\n    return uniqueArgumentFields\r\n}\r\n\r\nfunction sort(a, b) {\r\n    var result = a - b;\r\n    if (isNaN(result)) {\r\n        if (!_isDefined(a)) {\r\n            return 1\r\n        }\r\n        if (!_isDefined(b)) {\r\n            return -1\r\n        }\r\n        return 0\r\n    }\r\n    return result\r\n}\r\n\r\nfunction sortByArgument(data, argumentField) {\r\n    return data.slice().sort((function(a, b) {\r\n        return sort(a[argumentField], b[argumentField])\r\n    }))\r\n}\r\n\r\nfunction sortByCallback(data, callback) {\r\n    return data.slice().sort(callback)\r\n}\r\n\r\nfunction checkValueTypeOfGroup(group, cell) {\r\n    group.series.forEach((function(series) {\r\n        series.getValueFields().forEach((function(field) {\r\n            group.valueType = getType(cell[field], group.valueType)\r\n        }))\r\n    }));\r\n    return group.valueType\r\n}\r\n\r\nfunction getSortByCategories(categories) {\r\n    var hash = {};\r\n    categories.forEach((function(value, i) {\r\n        hash[value] = i\r\n    }));\r\n    return function(data, argumentField) {\r\n        return sortValues(data.slice(), true, (function(a) {\r\n            return hash[a[argumentField]]\r\n        }))\r\n    }\r\n}\r\n\r\nfunction sortData(data, groupsData, options, uniqueArgumentFields) {\r\n    var dataByArguments = {};\r\n    var isDiscrete = groupsData.argumentAxisType === DISCRETE;\r\n    var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;\r\n    var sortFunction = function(data) {\r\n        return data\r\n    };\r\n    var sortingMethodOption = options.sortingMethod;\r\n    var reSortCategories;\r\n    if (!userCategories && _isFunction(sortingMethodOption)) {\r\n        data = sortByCallback(data, sortingMethodOption)\r\n    }\r\n    if (isDiscrete) {\r\n        groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories)\r\n    }\r\n    if (userCategories || !_isFunction(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {\r\n        sortFunction = getSortByCategories(groupsData.categories)\r\n    } else if (true === sortingMethodOption && groupsData.argumentType !== STRING) {\r\n        sortFunction = sortByArgument;\r\n        reSortCategories = isDiscrete\r\n    }\r\n    uniqueArgumentFields.forEach((function(field) {\r\n        dataByArguments[field] = sortFunction(data, field)\r\n    }));\r\n    if (reSortCategories) {\r\n        groupsData.categories = groupsData.categories.sort(sort)\r\n    }\r\n    return dataByArguments\r\n}\r\n\r\nfunction checkItemExistence(collection, item) {\r\n    return -1 === collection.map((function(collectionItem) {\r\n        return collectionItem.valueOf()\r\n    })).indexOf(item.valueOf())\r\n}\r\n\r\nfunction getCategories(data, uniqueArgumentFields, userCategories) {\r\n    var categories = userCategories ? userCategories.slice() : [];\r\n    uniqueArgumentFields.forEach((function(field) {\r\n        data.forEach((function(item) {\r\n            var dataItem = item[field];\r\n            _isDefined(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem)\r\n        }))\r\n    }));\r\n    return categories\r\n}\r\n\r\nfunction checkArgumentTypeOfGroup(series, cell, groupsData) {\r\n    series.forEach((function(currentSeries) {\r\n        groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType)\r\n    }));\r\n    return groupsData.argumentType\r\n}\r\n\r\nfunction checkType(data, groupsData, checkTypeForAllData) {\r\n    var groupsWithUndefinedValueType = [];\r\n    var groupsWithUndefinedArgumentType = [];\r\n    var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);\r\n    var groupsIndexes;\r\n    groupsData.groups.forEach((function(group) {\r\n        if (!group.series.length) {\r\n            return\r\n        }\r\n        var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);\r\n        group.valueType = valueTypeGroup;\r\n        groupsData.argumentType = argumentTypeGroup;\r\n        !valueTypeGroup && groupsWithUndefinedValueType.push(group);\r\n        !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group)\r\n    }));\r\n    if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {\r\n        groupsIndexes = groupsWithUndefinedValueType.map((function(_, index) {\r\n            return index\r\n        }));\r\n        data.some((function(cell) {\r\n            var defineArg;\r\n            groupsWithUndefinedValueType.forEach((function(group, groupIndex) {\r\n                if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {\r\n                    groupsIndexes.splice(groupIndex, 1)\r\n                }\r\n            }));\r\n            if (!defineArg) {\r\n                groupsWithUndefinedArgumentType.forEach((function(group) {\r\n                    defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData)\r\n                }))\r\n            }\r\n            if (!checkTypeForAllData && defineArg && 0 === groupsIndexes.length) {\r\n                return true\r\n            }\r\n        }))\r\n    }\r\n}\r\n\r\nfunction checkAxisType(groupsData, incidentOccurred) {\r\n    var argumentOptions = groupsData.argumentOptions || {};\r\n    var userArgumentCategories = argumentOptions && argumentOptions.categories || [];\r\n    var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);\r\n    groupsData.groups.forEach((function(group) {\r\n        var valueOptions = group.valueOptions || {};\r\n        var valueCategories = valueOptions.categories || [];\r\n        var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);\r\n        group.series.forEach((function(series) {\r\n            var optionsSeries = {};\r\n            optionsSeries.argumentAxisType = argumentAxisType;\r\n            optionsSeries.valueAxisType = valueAxisType;\r\n            groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;\r\n            group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;\r\n            optionsSeries.argumentType = groupsData.argumentType;\r\n            optionsSeries.valueType = group.valueType;\r\n            optionsSeries.showZero = valueOptions.showZero;\r\n            series.updateDataType(optionsSeries)\r\n        }));\r\n        group.valueAxisType = group.valueAxisType || valueAxisType;\r\n        if (group.valueAxis) {\r\n            group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);\r\n            group.valueAxis.validate()\r\n        }\r\n    }));\r\n    groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;\r\n    if (groupsData.argumentAxes) {\r\n        groupsData.argumentAxes.forEach((function(axis) {\r\n            axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);\r\n            axis.validate()\r\n        }))\r\n    }\r\n}\r\n\r\nfunction verifyData(source, incidentOccurred) {\r\n    var data = [];\r\n    var sourceIsDefined = _isDefined(source);\r\n    var hasError = sourceIsDefined && !_isArray(source);\r\n    var i;\r\n    var ii;\r\n    var k;\r\n    var item;\r\n    if (sourceIsDefined && !hasError) {\r\n        for (i = 0, ii = source.length, k = 0; i < ii; ++i) {\r\n            item = source[i];\r\n            if (_isObject(item)) {\r\n                data[k++] = item\r\n            } else if (item) {\r\n                hasError = true\r\n            }\r\n        }\r\n    }\r\n    if (hasError) {\r\n        incidentOccurred(\"E2001\")\r\n    }\r\n    return data\r\n}\r\nexport function validateData(data, groupsData, incidentOccurred, options) {\r\n    data = verifyData(data, incidentOccurred);\r\n    groupsData.argumentType = groupsData.argumentAxisType = null;\r\n    processGroups(groupsData.groups);\r\n    resetArgumentAxes(groupsData.argumentAxes);\r\n    checkType(data, groupsData, options.checkTypeForAllData);\r\n    checkAxisType(groupsData, incidentOccurred);\r\n    if (options.convertToAxisDataType) {\r\n        data = parse(data, prepareParsers(groupsData, incidentOccurred))\r\n    }\r\n    groupPieData(data, groupsData);\r\n    var dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));\r\n    return dataByArgumentFields\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}