{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unshift.js\";\n/**\r\n * DevExtreme (esm/viz/series/line_series.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { chart as chartScatterSeries, polar as polarScatterSeries } from \"./scatter_series\";\nimport { clone } from \"../../core/utils/object\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport { map, normalizeAngle, getCosAndSin } from \"../core/utils\";\nimport { solveCubicEquation, trunc } from \"../../core/utils/math\";\nvar DISCRETE = \"discrete\";\nvar {\n  round: round,\n  sqrt: sqrt,\n  pow: pow,\n  min: min,\n  max: max,\n  abs: abs\n} = Math;\nvar chart = {};\nvar polar = {};\nfunction clonePoint(point, newX, newY, newAngle) {\n  var p = clone(point);\n  p.x = newX;\n  p.y = newY;\n  p.angle = newAngle;\n  return p;\n}\nfunction getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {\n  var correctAngle = point.angle + nextStepAngle;\n  var cosSin = getCosAndSin(correctAngle);\n  var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;\n  var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;\n  return clonePoint(prevPoint, x, y, correctAngle);\n}\nfunction obtainCubicBezierTCoef(p, p0, p1, p2, p3) {\n  var d = p0 - p;\n  var c = 3 * p1 - 3 * p0;\n  var b = 3 * p2 - 6 * p1 + 3 * p0;\n  var a = p3 - 3 * p2 + 3 * p1 - p0;\n  return solveCubicEquation(a, b, c, d);\n}\nvar lineMethods = {\n  autoHidePointMarkersEnabled: () => true,\n  _applyGroupSettings: function (style, settings, group) {\n    settings = extend(settings, style);\n    this._applyElementsClipRect(settings);\n    group.attr(settings);\n  },\n  _setGroupsSettings: function (animationEnabled) {\n    var style = this._styles.normal;\n    this._applyGroupSettings(style.elements, {\n      class: \"dxc-elements\"\n    }, this._elementsGroup);\n    this._bordersGroup && this._applyGroupSettings(style.border, {\n      class: \"dxc-borders\"\n    }, this._bordersGroup);\n    chartScatterSeries._setGroupsSettings.call(this, animationEnabled);\n    animationEnabled && this._markersGroup && this._markersGroup.attr({\n      opacity: .001\n    });\n  },\n  _createGroups: function () {\n    this._createGroup(\"_elementsGroup\", this, this._group);\n    this._areBordersVisible() && this._createGroup(\"_bordersGroup\", this, this._group);\n    chartScatterSeries._createGroups.call(this);\n  },\n  _areBordersVisible: function () {\n    return false;\n  },\n  _getDefaultSegment: function (segment) {\n    return {\n      line: map(segment.line || [], function (pt) {\n        return pt.getDefaultCoords();\n      })\n    };\n  },\n  _prepareSegment: function (points) {\n    return {\n      line: points\n    };\n  },\n  _parseLineOptions: function (options, defaultColor) {\n    return {\n      stroke: options.color || defaultColor,\n      \"stroke-width\": options.width,\n      dashStyle: options.dashStyle || \"solid\"\n    };\n  },\n  _parseStyle: function (options, defaultColor) {\n    return {\n      elements: this._parseLineOptions(options, defaultColor)\n    };\n  },\n  _applyStyle: function (style) {\n    this._elementsGroup && this._elementsGroup.attr(style.elements);\n    each(this._graphics || [], function (_, graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.elements[\"stroke-width\"]\n      }).sharp();\n    });\n  },\n  _drawElement: function (segment, group) {\n    return {\n      line: this._createMainElement(segment.line, {\n        \"stroke-width\": this._styles.normal.elements[\"stroke-width\"]\n      }).append(group)\n    };\n  },\n  _removeElement: function (element) {\n    element.line.remove();\n  },\n  _updateElement: function (element, segment, animate, animationComplete) {\n    var params = {\n      points: segment.line\n    };\n    var lineElement = element.line;\n    animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params);\n  },\n  _animateComplete: function () {\n    chartScatterSeries._animateComplete.call(this);\n    this._markersGroup && this._markersGroup.animate({\n      opacity: 1\n    }, {\n      duration: this._defaultDuration\n    });\n  },\n  _animate: function () {\n    var that = this;\n    var lastIndex = that._graphics.length - 1;\n    each(that._graphics || [], function (i, elem) {\n      var complete;\n      if (i === lastIndex) {\n        complete = function () {\n          that._animateComplete();\n        };\n      }\n      that._updateElement(elem, that._segments[i], true, complete);\n    });\n  },\n  _drawPoint: function (options) {\n    chartScatterSeries._drawPoint.call(this, {\n      point: options.point,\n      groups: options.groups\n    });\n  },\n  _createMainElement: function (points, settings) {\n    return this._renderer.path(points, \"line\").attr(settings);\n  },\n  _sortPoints: function (points, rotated) {\n    return rotated ? points.sort(function (p1, p2) {\n      return p2.y - p1.y;\n    }) : points.sort(function (p1, p2) {\n      return p1.x - p2.x;\n    });\n  },\n  _drawSegment: function (points, animationEnabled, segmentCount, lastSegment) {\n    var rotated = this._options.rotated;\n    var segment = this._prepareSegment(points, rotated, lastSegment);\n    this._segments.push(segment);\n    if (!this._graphics[segmentCount]) {\n      this._graphics[segmentCount] = this._drawElement(animationEnabled ? this._getDefaultSegment(segment) : segment, this._elementsGroup);\n    } else if (!animationEnabled) {\n      this._updateElement(this._graphics[segmentCount], segment);\n    }\n  },\n  _getTrackerSettings: function () {\n    var defaultTrackerWidth = this._defaultTrackerWidth;\n    var strokeWidthFromElements = this._styles.normal.elements[\"stroke-width\"];\n    return {\n      \"stroke-width\": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,\n      fill: \"none\"\n    };\n  },\n  _getMainPointsFromSegment: function (segment) {\n    return segment.line;\n  },\n  _drawTrackerElement: function (segment) {\n    return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment));\n  },\n  _updateTrackerElement: function (segment, element) {\n    var settings = this._getTrackerSettings(segment);\n    settings.points = this._getMainPointsFromSegment(segment);\n    element.attr(settings);\n  },\n  checkSeriesViewportCoord(axis, coord) {\n    if (!chartScatterSeries.checkSeriesViewportCoord.call(this)) {\n      return false;\n    }\n    var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();\n    var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);\n    var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\n    var rotated = this.getOptions().rotated;\n    var inverted = axis.getOptions().inverted;\n    return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min;\n  }\n};\nvar lineSeries = chart.line = extend({}, chartScatterSeries, lineMethods, {\n  getPointCenterByArg(arg) {\n    var value = this.getArgumentAxis().getTranslator().translate(arg);\n    return {\n      x: value,\n      y: value\n    };\n  },\n  getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord = null;\n    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\n    var needValueCoord = isArgument && !this._options.rotated || !isArgument && this._options.rotated;\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);\n      var b = p[0].vy - p[0].vx * k;\n      var tmpCoord = void 0;\n      if (p[1].vx - p[0].vx === 0) {\n        tmpCoord = needValueCoord ? p[0].vy : p[0].vx;\n      } else {\n        tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k;\n      }\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n    return oppositeCoord;\n  }\n});\nchart.stepline = extend({}, lineSeries, {\n  _calculateStepLinePoints(points) {\n    var segment = [];\n    var coordName = this._options.rotated ? \"x\" : \"y\";\n    each(points, function (i, pt) {\n      var point;\n      if (!i) {\n        segment.push(pt);\n        return;\n      }\n      var step = segment[segment.length - 1][coordName];\n      if (step !== pt[coordName]) {\n        point = clone(pt);\n        point[coordName] = step;\n        segment.push(point);\n      }\n      segment.push(pt);\n    });\n    return segment;\n  },\n  _prepareSegment: function (points) {\n    return lineSeries._prepareSegment(this._calculateStepLinePoints(points));\n  },\n  getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord;\n    var rotated = this._options.rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var tmpCoord = void 0;\n      if (isArgument) {\n        tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      } else {\n        tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      }\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n    return oppositeCoord;\n  }\n});\nchart.spline = extend({}, lineSeries, {\n  _calculateBezierPoints: function (src, rotated) {\n    var bezierPoints = [];\n    var pointsCopy = src;\n    var checkExtremum = function (otherPointCoord, pointCoord, controlCoord) {\n      return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord;\n    };\n    if (1 !== pointsCopy.length) {\n      pointsCopy.forEach(function (curPoint, i) {\n        var leftControlX;\n        var leftControlY;\n        var rightControlX;\n        var rightControlY;\n        var prevPoint = pointsCopy[i - 1];\n        var nextPoint = pointsCopy[i + 1];\n        var x1;\n        var x2;\n        var y1;\n        var y2;\n        var a;\n        var b;\n        var c;\n        var xc;\n        var yc;\n        var shift;\n        if (!i || i === pointsCopy.length - 1) {\n          bezierPoints.push(curPoint, curPoint);\n          return;\n        }\n        var xCur = curPoint.x;\n        var yCur = curPoint.y;\n        x1 = prevPoint.x;\n        x2 = nextPoint.x;\n        y1 = prevPoint.y;\n        y2 = nextPoint.y;\n        var curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));\n        if (curIsExtremum) {\n          if (!rotated) {\n            rightControlY = leftControlY = yCur;\n            rightControlX = (xCur + nextPoint.x) / 2;\n            leftControlX = (xCur + prevPoint.x) / 2;\n          } else {\n            rightControlX = leftControlX = xCur;\n            rightControlY = (yCur + nextPoint.y) / 2;\n            leftControlY = (yCur + prevPoint.y) / 2;\n          }\n        } else {\n          a = y2 - y1;\n          b = x1 - x2;\n          c = y1 * x2 - x1 * y2;\n          if (!rotated) {\n            if (!b) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n            xc = xCur;\n            yc = -1 * (a * xc + c) / b;\n            shift = yc - yCur;\n            y1 -= shift;\n            y2 -= shift;\n          } else {\n            if (!a) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n            yc = yCur;\n            xc = -1 * (b * yc + c) / a;\n            shift = xc - xCur;\n            x1 -= shift;\n            x2 -= shift;\n          }\n          rightControlX = (xCur + .5 * x2) / 1.5;\n          rightControlY = (yCur + .5 * y2) / 1.5;\n          leftControlX = (xCur + .5 * x1) / 1.5;\n          leftControlY = (yCur + .5 * y1) / 1.5;\n        }\n        if (!rotated) {\n          leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);\n          rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY);\n        } else {\n          leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);\n          rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX);\n        }\n        var leftPoint = clonePoint(curPoint, leftControlX, leftControlY);\n        var rightPoint = clonePoint(curPoint, rightControlX, rightControlY);\n        bezierPoints.push(leftPoint, curPoint, rightPoint);\n      });\n    } else {\n      bezierPoints.push(pointsCopy[0]);\n    }\n    return bezierPoints;\n  },\n  _prepareSegment: function (points, rotated) {\n    return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated));\n  },\n  _createMainElement: function (points, settings) {\n    return this._renderer.path(points, \"bezier\").attr(settings);\n  },\n  getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord = null;\n    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var bezierCoordName = !isOpposite ? \"x\" : \"y\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var bezierOppositeCoordName = !isOpposite ? \"y\" : \"x\";\n    var axis = !isArgument ? this.getArgumentAxis() : this.getValueAxis();\n    var visibleArea = axis.getVisibleArea();\n    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\n    var _loop = function (i) {\n      var p = nearestPoints[i];\n      if (1 === p.length) {\n        visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName]);\n      } else {\n        var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);\n        ts.forEach(t => {\n          if (t >= 0 && t <= 1) {\n            var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];\n            if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {\n              oppositeCoord = tmpCoord;\n            }\n          }\n        });\n      }\n      if (null !== oppositeCoord) {\n        return \"break\";\n      }\n    };\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var _ret = _loop(i);\n      if (\"break\" === _ret) {\n        break;\n      }\n    }\n    return oppositeCoord;\n  },\n  _getNearestPoints(point, nextPoint, bezierPoints) {\n    var index = bezierPoints.indexOf(point);\n    return [point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint];\n  },\n  _getBezierPoints() {\n    return this._segments.length > 0 ? this._segments.reduce((a, seg) => a.concat(seg.line), []) : [];\n  }\n});\npolar.line = extend({}, polarScatterSeries, lineMethods, {\n  _sortPoints: function (points) {\n    return points;\n  },\n  _prepareSegment: function (points, rotated, lastSegment) {\n    var preparedPoints = [];\n    var centerPoint = this.getValueAxis().getCenter();\n    var i;\n    lastSegment && this._closeSegment(points);\n    if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\n      for (i = 1; i < points.length; i++) {\n        preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint, i === points.length - 1));\n      }\n      if (!preparedPoints.length) {\n        preparedPoints = points;\n      }\n    } else {\n      return lineSeries._prepareSegment.call(this, points);\n    }\n    return {\n      line: preparedPoints\n    };\n  },\n  _getRemainingAngle: function (angle) {\n    var normAngle = normalizeAngle(angle);\n    return angle >= 0 ? 360 - normAngle : -normAngle;\n  },\n  _closeSegment(points) {\n    var point;\n    if (this._segments.length) {\n      point = this._segments[0].line[0];\n    } else {\n      point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\n    }\n    point = this._modifyReflectedPoint(point, points[points.length - 1]);\n    if (point) {\n      points.push(point);\n    }\n  },\n  _modifyReflectedPoint(point, lastPoint) {\n    if (lastPoint.angle === point.angle) {\n      return;\n    }\n    if (normalizeAngle(round(lastPoint.angle)) === normalizeAngle(round(point.angle))) {\n      point.angle = lastPoint.angle;\n    } else {\n      var differenceAngle = lastPoint.angle - point.angle;\n      point.angle = lastPoint.angle + this._getRemainingAngle(differenceAngle);\n    }\n    return point;\n  },\n  _getTangentPoints: function (point, prevPoint, centerPoint, isLastSegment) {\n    var tangentPoints = [];\n    var betweenAngle = Math.round(prevPoint.angle - point.angle);\n    var tan = (prevPoint.radius - point.radius) / betweenAngle;\n    var i;\n    if (0 === betweenAngle) {\n      tangentPoints = [prevPoint, point];\n    } else if (betweenAngle > 0) {\n      var angle = isLastSegment ? betweenAngle : betweenAngle - 1;\n      for (i = angle; i >= 0; i--) {\n        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i));\n      }\n    } else {\n      var _angle = isLastSegment ? betweenAngle : betweenAngle + 1;\n      for (i = 0; i >= _angle; i--) {\n        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i));\n      }\n    }\n    return tangentPoints;\n  },\n  getSeriesPairCoord(params, isArgument) {\n    var argAxis = this.getArgumentAxis();\n    var paramName = isArgument ? \"angle\" : \"radius\";\n    var coordParam = params[paramName];\n    var centerPoint = argAxis.getCenter();\n    var isInsideInterval = (prevPoint, point, _ref) => {\n      var {\n        x: x,\n        y: y\n      } = _ref;\n      return (p1 = {\n        x: x,\n        y: y\n      }, p2 = centerPoint, sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2))) <= argAxis.getRadius() && min(prevPoint.x, point.x) <= x && max(prevPoint.x, point.x) >= x && min(prevPoint.y, point.y) <= y && max(prevPoint.y, point.y) >= y;\n      var p1, p2;\n    };\n    var coords;\n    var neighborPoints = this.getNeighborPoints(coordParam, paramName);\n    if (1 === neighborPoints.length) {\n      coords = neighborPoints[0];\n    } else if (neighborPoints.length > 1) {\n      var prevPoint = neighborPoints[0];\n      var point = neighborPoints[1];\n      if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\n        var tan;\n        var stepAngle;\n        if (isArgument) {\n          tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\n          stepAngle = coordParam - point.angle;\n        } else {\n          tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\n          stepAngle = (coordParam - point.radius) / tan;\n        }\n        coords = getTangentPoint(point, prevPoint, centerPoint, tan, stepAngle);\n      } else if (isArgument) {\n        var cosSin = getCosAndSin(-coordParam);\n        var k1 = (point.y - prevPoint.y) / (point.x - prevPoint.x);\n        var b1 = prevPoint.y - prevPoint.x * k1;\n        var k2 = cosSin.sin / cosSin.cos;\n        var b2 = centerPoint.y - k2 * centerPoint.x;\n        var x = (b2 - b1) / (k1 - k2);\n        var y = k1 * x + b1;\n        if (isInsideInterval(prevPoint, point, {\n          x: x,\n          y: y\n        })) {\n          var quarter = abs(trunc((360 + coordParam) / 90) % 4);\n          if (0 === quarter && x >= centerPoint.x && y <= centerPoint.y || 1 === quarter && x <= centerPoint.x && y <= centerPoint.y || 2 === quarter && x <= centerPoint.x && y >= centerPoint.y || 3 === quarter && x >= centerPoint.x && y >= centerPoint.y) {\n            coords = {\n              x: x,\n              y: y\n            };\n          }\n        }\n      } else {\n        var k = (point.y - prevPoint.y) / (point.x - prevPoint.x);\n        var y0 = prevPoint.y - prevPoint.x * k;\n        var a = 1 + k * k;\n        var b = -2 * centerPoint.x + 2 * k * y0 - 2 * k * centerPoint.y;\n        var c = -pow(coordParam, 2) + pow(y0 - centerPoint.y, 2) + pow(centerPoint.x, 2);\n        var d = b * b - 4 * a * c;\n        if (d >= 0) {\n          var x1 = (-b - sqrt(d)) / (2 * a);\n          var x2 = (-b + sqrt(d)) / (2 * a);\n          var y1 = k * x1 + y0;\n          var y2 = k * x2 + y0;\n          coords = isInsideInterval(prevPoint, point, {\n            x: x1,\n            y: y1\n          }) ? {\n            x: x1,\n            y: y1\n          } : isInsideInterval(prevPoint, point, {\n            x: x2,\n            y: y2\n          }) ? {\n            x: x2,\n            y: y2\n          } : void 0;\n        }\n      }\n    }\n    return coords;\n  },\n  getNeighborPoints(param, paramName) {\n    var points = this.getPoints();\n    var neighborPoints = [];\n    if (this.getOptions().closed) {\n      points = extend(true, [], points);\n      var lastPoint = points[points.length - 1];\n      var firstPointCopy = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\n      var lastPointCopy = clonePoint(lastPoint, lastPoint.x, lastPoint.y, lastPoint.angle);\n      var rearwardRefPoint = this._modifyReflectedPoint(firstPointCopy, lastPoint);\n      var forwardRefPoint = this._modifyReflectedPoint(lastPointCopy, points[0]);\n      if (forwardRefPoint) {\n        points.unshift(forwardRefPoint);\n      }\n      if (rearwardRefPoint) {\n        points.push(rearwardRefPoint);\n      }\n    }\n    for (var i = 1; i < points.length; i++) {\n      if (points[i - 1][paramName] === param) {\n        neighborPoints.push(points[i - 1]);\n      } else if (points[i][paramName] === param) {\n        neighborPoints.push(points[i]);\n      } else if (points[i][paramName] > param && points[i - 1][paramName] < param || points[i - 1][paramName] > param && points[i][paramName] < param) {\n        neighborPoints.push(points[i - 1]);\n        neighborPoints.push(points[i]);\n      }\n      if (neighborPoints.length > 0) {\n        break;\n      }\n    }\n    return neighborPoints;\n  }\n});\nexport { chart, polar };","map":{"version":3,"names":["chart","chartScatterSeries","polar","polarScatterSeries","clone","extend","each","map","normalizeAngle","getCosAndSin","solveCubicEquation","trunc","DISCRETE","round","sqrt","pow","min","max","abs","Math","clonePoint","point","newX","newY","newAngle","p","x","y","angle","getTangentPoint","prevPoint","centerPoint","tan","nextStepAngle","correctAngle","cosSin","radius","cos","sin","obtainCubicBezierTCoef","p0","p1","p2","p3","d","c","b","a","lineMethods","autoHidePointMarkersEnabled","_applyGroupSettings","style","settings","group","_applyElementsClipRect","attr","_setGroupsSettings","animationEnabled","_styles","normal","elements","class","_elementsGroup","_bordersGroup","border","call","_markersGroup","opacity","_createGroups","_createGroup","_group","_areBordersVisible","_getDefaultSegment","segment","line","pt","getDefaultCoords","_prepareSegment","points","_parseLineOptions","options","defaultColor","stroke","color","width","dashStyle","_parseStyle","_applyStyle","_graphics","_","graphic","sharp","_drawElement","_createMainElement","append","_removeElement","element","remove","_updateElement","animate","animationComplete","params","lineElement","_animateComplete","duration","_defaultDuration","_animate","that","lastIndex","length","i","elem","complete","_segments","_drawPoint","groups","_renderer","path","_sortPoints","rotated","sort","_drawSegment","segmentCount","lastSegment","_options","push","_getTrackerSettings","defaultTrackerWidth","_defaultTrackerWidth","strokeWidthFromElements","fill","_getMainPointsFromSegment","_drawTrackerElement","_updateTrackerElement","checkSeriesViewportCoord","axis","coord","range","isArgumentAxis","getArgumentRange","getViewport","getTranslator","translate","categories","getOptions","inverted","lineSeries","getPointCenterByArg","arg","value","getArgumentAxis","getSeriesPairCoord","isArgument","oppositeCoord","nearestPoints","_getNearestPointsByCoord","needValueCoord","k","vy","vx","tmpCoord","_checkAxisVisibleAreaCoord","stepline","_calculateStepLinePoints","coordName","step","isOpposite","oppositeCoordName","spline","_calculateBezierPoints","src","bezierPoints","pointsCopy","checkExtremum","otherPointCoord","pointCoord","controlCoord","forEach","curPoint","leftControlX","leftControlY","rightControlX","rightControlY","nextPoint","x1","x2","y1","y2","xc","yc","shift","xCur","yCur","curIsExtremum","leftPoint","rightPoint","bezierCoordName","bezierOppositeCoordName","getValueAxis","visibleArea","getVisibleArea","_loop","ts","t","_ret","_getNearestPoints","index","indexOf","_getBezierPoints","reduce","seg","concat","preparedPoints","getCenter","_closeSegment","argumentAxisType","valueAxisType","_getTangentPoints","_getRemainingAngle","normAngle","_modifyReflectedPoint","lastPoint","differenceAngle","isLastSegment","tangentPoints","betweenAngle","_angle","argAxis","paramName","coordParam","isInsideInterval","_ref","getRadius","coords","neighborPoints","getNeighborPoints","stepAngle","k1","b1","k2","b2","quarter","y0","param","getPoints","closed","firstPointCopy","lastPointCopy","rearwardRefPoint","forwardRefPoint","unshift"],"sources":["C:/Users/User/vue-chart/node_modules/devextreme/esm/viz/series/line_series.js"],"sourcesContent":["/**\r\n * DevExtreme (esm/viz/series/line_series.js)\r\n * Version: 22.1.6\r\n * Build date: Tue Oct 18 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    chart as chartScatterSeries,\r\n    polar as polarScatterSeries\r\n} from \"./scatter_series\";\r\nimport {\r\n    clone\r\n} from \"../../core/utils/object\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    each\r\n} from \"../../core/utils/iterator\";\r\nimport {\r\n    map,\r\n    normalizeAngle,\r\n    getCosAndSin\r\n} from \"../core/utils\";\r\nimport {\r\n    solveCubicEquation,\r\n    trunc\r\n} from \"../../core/utils/math\";\r\nvar DISCRETE = \"discrete\";\r\nvar {\r\n    round: round,\r\n    sqrt: sqrt,\r\n    pow: pow,\r\n    min: min,\r\n    max: max,\r\n    abs: abs\r\n} = Math;\r\nvar chart = {};\r\nvar polar = {};\r\n\r\nfunction clonePoint(point, newX, newY, newAngle) {\r\n    var p = clone(point);\r\n    p.x = newX;\r\n    p.y = newY;\r\n    p.angle = newAngle;\r\n    return p\r\n}\r\n\r\nfunction getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {\r\n    var correctAngle = point.angle + nextStepAngle;\r\n    var cosSin = getCosAndSin(correctAngle);\r\n    var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;\r\n    var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;\r\n    return clonePoint(prevPoint, x, y, correctAngle)\r\n}\r\n\r\nfunction obtainCubicBezierTCoef(p, p0, p1, p2, p3) {\r\n    var d = p0 - p;\r\n    var c = 3 * p1 - 3 * p0;\r\n    var b = 3 * p2 - 6 * p1 + 3 * p0;\r\n    var a = p3 - 3 * p2 + 3 * p1 - p0;\r\n    return solveCubicEquation(a, b, c, d)\r\n}\r\nvar lineMethods = {\r\n    autoHidePointMarkersEnabled: () => true,\r\n    _applyGroupSettings: function(style, settings, group) {\r\n        settings = extend(settings, style);\r\n        this._applyElementsClipRect(settings);\r\n        group.attr(settings)\r\n    },\r\n    _setGroupsSettings: function(animationEnabled) {\r\n        var style = this._styles.normal;\r\n        this._applyGroupSettings(style.elements, {\r\n            class: \"dxc-elements\"\r\n        }, this._elementsGroup);\r\n        this._bordersGroup && this._applyGroupSettings(style.border, {\r\n            class: \"dxc-borders\"\r\n        }, this._bordersGroup);\r\n        chartScatterSeries._setGroupsSettings.call(this, animationEnabled);\r\n        animationEnabled && this._markersGroup && this._markersGroup.attr({\r\n            opacity: .001\r\n        })\r\n    },\r\n    _createGroups: function() {\r\n        this._createGroup(\"_elementsGroup\", this, this._group);\r\n        this._areBordersVisible() && this._createGroup(\"_bordersGroup\", this, this._group);\r\n        chartScatterSeries._createGroups.call(this)\r\n    },\r\n    _areBordersVisible: function() {\r\n        return false\r\n    },\r\n    _getDefaultSegment: function(segment) {\r\n        return {\r\n            line: map(segment.line || [], (function(pt) {\r\n                return pt.getDefaultCoords()\r\n            }))\r\n        }\r\n    },\r\n    _prepareSegment: function(points) {\r\n        return {\r\n            line: points\r\n        }\r\n    },\r\n    _parseLineOptions: function(options, defaultColor) {\r\n        return {\r\n            stroke: options.color || defaultColor,\r\n            \"stroke-width\": options.width,\r\n            dashStyle: options.dashStyle || \"solid\"\r\n        }\r\n    },\r\n    _parseStyle: function(options, defaultColor) {\r\n        return {\r\n            elements: this._parseLineOptions(options, defaultColor)\r\n        }\r\n    },\r\n    _applyStyle: function(style) {\r\n        this._elementsGroup && this._elementsGroup.attr(style.elements);\r\n        each(this._graphics || [], (function(_, graphic) {\r\n            graphic.line && graphic.line.attr({\r\n                \"stroke-width\": style.elements[\"stroke-width\"]\r\n            }).sharp()\r\n        }))\r\n    },\r\n    _drawElement: function(segment, group) {\r\n        return {\r\n            line: this._createMainElement(segment.line, {\r\n                \"stroke-width\": this._styles.normal.elements[\"stroke-width\"]\r\n            }).append(group)\r\n        }\r\n    },\r\n    _removeElement: function(element) {\r\n        element.line.remove()\r\n    },\r\n    _updateElement: function(element, segment, animate, animationComplete) {\r\n        var params = {\r\n            points: segment.line\r\n        };\r\n        var lineElement = element.line;\r\n        animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params)\r\n    },\r\n    _animateComplete: function() {\r\n        chartScatterSeries._animateComplete.call(this);\r\n        this._markersGroup && this._markersGroup.animate({\r\n            opacity: 1\r\n        }, {\r\n            duration: this._defaultDuration\r\n        })\r\n    },\r\n    _animate: function() {\r\n        var that = this;\r\n        var lastIndex = that._graphics.length - 1;\r\n        each(that._graphics || [], (function(i, elem) {\r\n            var complete;\r\n            if (i === lastIndex) {\r\n                complete = function() {\r\n                    that._animateComplete()\r\n                }\r\n            }\r\n            that._updateElement(elem, that._segments[i], true, complete)\r\n        }))\r\n    },\r\n    _drawPoint: function(options) {\r\n        chartScatterSeries._drawPoint.call(this, {\r\n            point: options.point,\r\n            groups: options.groups\r\n        })\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"line\").attr(settings)\r\n    },\r\n    _sortPoints: function(points, rotated) {\r\n        return rotated ? points.sort((function(p1, p2) {\r\n            return p2.y - p1.y\r\n        })) : points.sort((function(p1, p2) {\r\n            return p1.x - p2.x\r\n        }))\r\n    },\r\n    _drawSegment: function(points, animationEnabled, segmentCount, lastSegment) {\r\n        var rotated = this._options.rotated;\r\n        var segment = this._prepareSegment(points, rotated, lastSegment);\r\n        this._segments.push(segment);\r\n        if (!this._graphics[segmentCount]) {\r\n            this._graphics[segmentCount] = this._drawElement(animationEnabled ? this._getDefaultSegment(segment) : segment, this._elementsGroup)\r\n        } else if (!animationEnabled) {\r\n            this._updateElement(this._graphics[segmentCount], segment)\r\n        }\r\n    },\r\n    _getTrackerSettings: function() {\r\n        var defaultTrackerWidth = this._defaultTrackerWidth;\r\n        var strokeWidthFromElements = this._styles.normal.elements[\"stroke-width\"];\r\n        return {\r\n            \"stroke-width\": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,\r\n            fill: \"none\"\r\n        }\r\n    },\r\n    _getMainPointsFromSegment: function(segment) {\r\n        return segment.line\r\n    },\r\n    _drawTrackerElement: function(segment) {\r\n        return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment))\r\n    },\r\n    _updateTrackerElement: function(segment, element) {\r\n        var settings = this._getTrackerSettings(segment);\r\n        settings.points = this._getMainPointsFromSegment(segment);\r\n        element.attr(settings)\r\n    },\r\n    checkSeriesViewportCoord(axis, coord) {\r\n        if (!chartScatterSeries.checkSeriesViewportCoord.call(this)) {\r\n            return false\r\n        }\r\n        var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();\r\n        var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);\r\n        var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\r\n        var rotated = this.getOptions().rotated;\r\n        var inverted = axis.getOptions().inverted;\r\n        return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min\r\n    }\r\n};\r\nvar lineSeries = chart.line = extend({}, chartScatterSeries, lineMethods, {\r\n    getPointCenterByArg(arg) {\r\n        var value = this.getArgumentAxis().getTranslator().translate(arg);\r\n        return {\r\n            x: value,\r\n            y: value\r\n        }\r\n    },\r\n    getSeriesPairCoord(coord, isArgument) {\r\n        var oppositeCoord = null;\r\n        var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\r\n        var needValueCoord = isArgument && !this._options.rotated || !isArgument && this._options.rotated;\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var p = nearestPoints[i];\r\n            var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);\r\n            var b = p[0].vy - p[0].vx * k;\r\n            var tmpCoord = void 0;\r\n            if (p[1].vx - p[0].vx === 0) {\r\n                tmpCoord = needValueCoord ? p[0].vy : p[0].vx\r\n            } else {\r\n                tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k\r\n            }\r\n            if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    }\r\n});\r\nchart.stepline = extend({}, lineSeries, {\r\n    _calculateStepLinePoints(points) {\r\n        var segment = [];\r\n        var coordName = this._options.rotated ? \"x\" : \"y\";\r\n        each(points, (function(i, pt) {\r\n            var point;\r\n            if (!i) {\r\n                segment.push(pt);\r\n                return\r\n            }\r\n            var step = segment[segment.length - 1][coordName];\r\n            if (step !== pt[coordName]) {\r\n                point = clone(pt);\r\n                point[coordName] = step;\r\n                segment.push(point)\r\n            }\r\n            segment.push(pt)\r\n        }));\r\n        return segment\r\n    },\r\n    _prepareSegment: function(points) {\r\n        return lineSeries._prepareSegment(this._calculateStepLinePoints(points))\r\n    },\r\n    getSeriesPairCoord(coord, isArgument) {\r\n        var oppositeCoord;\r\n        var rotated = this._options.rotated;\r\n        var isOpposite = !isArgument && !rotated || isArgument && rotated;\r\n        var coordName = !isOpposite ? \"vx\" : \"vy\";\r\n        var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\r\n        var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var p = nearestPoints[i];\r\n            var tmpCoord = void 0;\r\n            if (isArgument) {\r\n                tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName]\r\n            } else {\r\n                tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName]\r\n            }\r\n            if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    }\r\n});\r\nchart.spline = extend({}, lineSeries, {\r\n    _calculateBezierPoints: function(src, rotated) {\r\n        var bezierPoints = [];\r\n        var pointsCopy = src;\r\n        var checkExtremum = function(otherPointCoord, pointCoord, controlCoord) {\r\n            return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord\r\n        };\r\n        if (1 !== pointsCopy.length) {\r\n            pointsCopy.forEach((function(curPoint, i) {\r\n                var leftControlX;\r\n                var leftControlY;\r\n                var rightControlX;\r\n                var rightControlY;\r\n                var prevPoint = pointsCopy[i - 1];\r\n                var nextPoint = pointsCopy[i + 1];\r\n                var x1;\r\n                var x2;\r\n                var y1;\r\n                var y2;\r\n                var a;\r\n                var b;\r\n                var c;\r\n                var xc;\r\n                var yc;\r\n                var shift;\r\n                if (!i || i === pointsCopy.length - 1) {\r\n                    bezierPoints.push(curPoint, curPoint);\r\n                    return\r\n                }\r\n                var xCur = curPoint.x;\r\n                var yCur = curPoint.y;\r\n                x1 = prevPoint.x;\r\n                x2 = nextPoint.x;\r\n                y1 = prevPoint.y;\r\n                y2 = nextPoint.y;\r\n                var curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));\r\n                if (curIsExtremum) {\r\n                    if (!rotated) {\r\n                        rightControlY = leftControlY = yCur;\r\n                        rightControlX = (xCur + nextPoint.x) / 2;\r\n                        leftControlX = (xCur + prevPoint.x) / 2\r\n                    } else {\r\n                        rightControlX = leftControlX = xCur;\r\n                        rightControlY = (yCur + nextPoint.y) / 2;\r\n                        leftControlY = (yCur + prevPoint.y) / 2\r\n                    }\r\n                } else {\r\n                    a = y2 - y1;\r\n                    b = x1 - x2;\r\n                    c = y1 * x2 - x1 * y2;\r\n                    if (!rotated) {\r\n                        if (!b) {\r\n                            bezierPoints.push(curPoint, curPoint, curPoint);\r\n                            return\r\n                        }\r\n                        xc = xCur;\r\n                        yc = -1 * (a * xc + c) / b;\r\n                        shift = yc - yCur;\r\n                        y1 -= shift;\r\n                        y2 -= shift\r\n                    } else {\r\n                        if (!a) {\r\n                            bezierPoints.push(curPoint, curPoint, curPoint);\r\n                            return\r\n                        }\r\n                        yc = yCur;\r\n                        xc = -1 * (b * yc + c) / a;\r\n                        shift = xc - xCur;\r\n                        x1 -= shift;\r\n                        x2 -= shift\r\n                    }\r\n                    rightControlX = (xCur + .5 * x2) / 1.5;\r\n                    rightControlY = (yCur + .5 * y2) / 1.5;\r\n                    leftControlX = (xCur + .5 * x1) / 1.5;\r\n                    leftControlY = (yCur + .5 * y1) / 1.5\r\n                }\r\n                if (!rotated) {\r\n                    leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);\r\n                    rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY)\r\n                } else {\r\n                    leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);\r\n                    rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX)\r\n                }\r\n                var leftPoint = clonePoint(curPoint, leftControlX, leftControlY);\r\n                var rightPoint = clonePoint(curPoint, rightControlX, rightControlY);\r\n                bezierPoints.push(leftPoint, curPoint, rightPoint)\r\n            }))\r\n        } else {\r\n            bezierPoints.push(pointsCopy[0])\r\n        }\r\n        return bezierPoints\r\n    },\r\n    _prepareSegment: function(points, rotated) {\r\n        return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated))\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"bezier\").attr(settings)\r\n    },\r\n    getSeriesPairCoord(coord, isArgument) {\r\n        var oppositeCoord = null;\r\n        var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\r\n        var coordName = !isOpposite ? \"vx\" : \"vy\";\r\n        var bezierCoordName = !isOpposite ? \"x\" : \"y\";\r\n        var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\r\n        var bezierOppositeCoordName = !isOpposite ? \"y\" : \"x\";\r\n        var axis = !isArgument ? this.getArgumentAxis() : this.getValueAxis();\r\n        var visibleArea = axis.getVisibleArea();\r\n        var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\r\n        var _loop = function(i) {\r\n            var p = nearestPoints[i];\r\n            if (1 === p.length) {\r\n                visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName])\r\n            } else {\r\n                var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);\r\n                ts.forEach(t => {\r\n                    if (t >= 0 && t <= 1) {\r\n                        var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];\r\n                        if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {\r\n                            oppositeCoord = tmpCoord\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n            if (null !== oppositeCoord) {\r\n                return \"break\"\r\n            }\r\n        };\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var _ret = _loop(i);\r\n            if (\"break\" === _ret) {\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    },\r\n    _getNearestPoints(point, nextPoint, bezierPoints) {\r\n        var index = bezierPoints.indexOf(point);\r\n        return [point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint]\r\n    },\r\n    _getBezierPoints() {\r\n        return this._segments.length > 0 ? this._segments.reduce((a, seg) => a.concat(seg.line), []) : []\r\n    }\r\n});\r\npolar.line = extend({}, polarScatterSeries, lineMethods, {\r\n    _sortPoints: function(points) {\r\n        return points\r\n    },\r\n    _prepareSegment: function(points, rotated, lastSegment) {\r\n        var preparedPoints = [];\r\n        var centerPoint = this.getValueAxis().getCenter();\r\n        var i;\r\n        lastSegment && this._closeSegment(points);\r\n        if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\r\n            for (i = 1; i < points.length; i++) {\r\n                preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint, i === points.length - 1))\r\n            }\r\n            if (!preparedPoints.length) {\r\n                preparedPoints = points\r\n            }\r\n        } else {\r\n            return lineSeries._prepareSegment.call(this, points)\r\n        }\r\n        return {\r\n            line: preparedPoints\r\n        }\r\n    },\r\n    _getRemainingAngle: function(angle) {\r\n        var normAngle = normalizeAngle(angle);\r\n        return angle >= 0 ? 360 - normAngle : -normAngle\r\n    },\r\n    _closeSegment(points) {\r\n        var point;\r\n        if (this._segments.length) {\r\n            point = this._segments[0].line[0]\r\n        } else {\r\n            point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle)\r\n        }\r\n        point = this._modifyReflectedPoint(point, points[points.length - 1]);\r\n        if (point) {\r\n            points.push(point)\r\n        }\r\n    },\r\n    _modifyReflectedPoint(point, lastPoint) {\r\n        if (lastPoint.angle === point.angle) {\r\n            return\r\n        }\r\n        if (normalizeAngle(round(lastPoint.angle)) === normalizeAngle(round(point.angle))) {\r\n            point.angle = lastPoint.angle\r\n        } else {\r\n            var differenceAngle = lastPoint.angle - point.angle;\r\n            point.angle = lastPoint.angle + this._getRemainingAngle(differenceAngle)\r\n        }\r\n        return point\r\n    },\r\n    _getTangentPoints: function(point, prevPoint, centerPoint, isLastSegment) {\r\n        var tangentPoints = [];\r\n        var betweenAngle = Math.round(prevPoint.angle - point.angle);\r\n        var tan = (prevPoint.radius - point.radius) / betweenAngle;\r\n        var i;\r\n        if (0 === betweenAngle) {\r\n            tangentPoints = [prevPoint, point]\r\n        } else if (betweenAngle > 0) {\r\n            var angle = isLastSegment ? betweenAngle : betweenAngle - 1;\r\n            for (i = angle; i >= 0; i--) {\r\n                tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i))\r\n            }\r\n        } else {\r\n            var _angle = isLastSegment ? betweenAngle : betweenAngle + 1;\r\n            for (i = 0; i >= _angle; i--) {\r\n                tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i))\r\n            }\r\n        }\r\n        return tangentPoints\r\n    },\r\n    getSeriesPairCoord(params, isArgument) {\r\n        var argAxis = this.getArgumentAxis();\r\n        var paramName = isArgument ? \"angle\" : \"radius\";\r\n        var coordParam = params[paramName];\r\n        var centerPoint = argAxis.getCenter();\r\n        var isInsideInterval = (prevPoint, point, _ref) => {\r\n            var {\r\n                x: x,\r\n                y: y\r\n            } = _ref;\r\n            return (p1 = {\r\n                x: x,\r\n                y: y\r\n            }, p2 = centerPoint, sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2))) <= argAxis.getRadius() && min(prevPoint.x, point.x) <= x && max(prevPoint.x, point.x) >= x && min(prevPoint.y, point.y) <= y && max(prevPoint.y, point.y) >= y;\r\n            var p1, p2\r\n        };\r\n        var coords;\r\n        var neighborPoints = this.getNeighborPoints(coordParam, paramName);\r\n        if (1 === neighborPoints.length) {\r\n            coords = neighborPoints[0]\r\n        } else if (neighborPoints.length > 1) {\r\n            var prevPoint = neighborPoints[0];\r\n            var point = neighborPoints[1];\r\n            if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\r\n                var tan;\r\n                var stepAngle;\r\n                if (isArgument) {\r\n                    tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\r\n                    stepAngle = coordParam - point.angle\r\n                } else {\r\n                    tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\r\n                    stepAngle = (coordParam - point.radius) / tan\r\n                }\r\n                coords = getTangentPoint(point, prevPoint, centerPoint, tan, stepAngle)\r\n            } else if (isArgument) {\r\n                var cosSin = getCosAndSin(-coordParam);\r\n                var k1 = (point.y - prevPoint.y) / (point.x - prevPoint.x);\r\n                var b1 = prevPoint.y - prevPoint.x * k1;\r\n                var k2 = cosSin.sin / cosSin.cos;\r\n                var b2 = centerPoint.y - k2 * centerPoint.x;\r\n                var x = (b2 - b1) / (k1 - k2);\r\n                var y = k1 * x + b1;\r\n                if (isInsideInterval(prevPoint, point, {\r\n                        x: x,\r\n                        y: y\r\n                    })) {\r\n                    var quarter = abs(trunc((360 + coordParam) / 90) % 4);\r\n                    if (0 === quarter && x >= centerPoint.x && y <= centerPoint.y || 1 === quarter && x <= centerPoint.x && y <= centerPoint.y || 2 === quarter && x <= centerPoint.x && y >= centerPoint.y || 3 === quarter && x >= centerPoint.x && y >= centerPoint.y) {\r\n                        coords = {\r\n                            x: x,\r\n                            y: y\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                var k = (point.y - prevPoint.y) / (point.x - prevPoint.x);\r\n                var y0 = prevPoint.y - prevPoint.x * k;\r\n                var a = 1 + k * k;\r\n                var b = -2 * centerPoint.x + 2 * k * y0 - 2 * k * centerPoint.y;\r\n                var c = -pow(coordParam, 2) + pow(y0 - centerPoint.y, 2) + pow(centerPoint.x, 2);\r\n                var d = b * b - 4 * a * c;\r\n                if (d >= 0) {\r\n                    var x1 = (-b - sqrt(d)) / (2 * a);\r\n                    var x2 = (-b + sqrt(d)) / (2 * a);\r\n                    var y1 = k * x1 + y0;\r\n                    var y2 = k * x2 + y0;\r\n                    coords = isInsideInterval(prevPoint, point, {\r\n                        x: x1,\r\n                        y: y1\r\n                    }) ? {\r\n                        x: x1,\r\n                        y: y1\r\n                    } : isInsideInterval(prevPoint, point, {\r\n                        x: x2,\r\n                        y: y2\r\n                    }) ? {\r\n                        x: x2,\r\n                        y: y2\r\n                    } : void 0\r\n                }\r\n            }\r\n        }\r\n        return coords\r\n    },\r\n    getNeighborPoints(param, paramName) {\r\n        var points = this.getPoints();\r\n        var neighborPoints = [];\r\n        if (this.getOptions().closed) {\r\n            points = extend(true, [], points);\r\n            var lastPoint = points[points.length - 1];\r\n            var firstPointCopy = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\r\n            var lastPointCopy = clonePoint(lastPoint, lastPoint.x, lastPoint.y, lastPoint.angle);\r\n            var rearwardRefPoint = this._modifyReflectedPoint(firstPointCopy, lastPoint);\r\n            var forwardRefPoint = this._modifyReflectedPoint(lastPointCopy, points[0]);\r\n            if (forwardRefPoint) {\r\n                points.unshift(forwardRefPoint)\r\n            }\r\n            if (rearwardRefPoint) {\r\n                points.push(rearwardRefPoint)\r\n            }\r\n        }\r\n        for (var i = 1; i < points.length; i++) {\r\n            if (points[i - 1][paramName] === param) {\r\n                neighborPoints.push(points[i - 1])\r\n            } else if (points[i][paramName] === param) {\r\n                neighborPoints.push(points[i])\r\n            } else if (points[i][paramName] > param && points[i - 1][paramName] < param || points[i - 1][paramName] > param && points[i][paramName] < param) {\r\n                neighborPoints.push(points[i - 1]);\r\n                neighborPoints.push(points[i])\r\n            }\r\n            if (neighborPoints.length > 0) {\r\n                break\r\n            }\r\n        }\r\n        return neighborPoints\r\n    }\r\n});\r\nexport {\r\n    chart,\r\n    polar\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}