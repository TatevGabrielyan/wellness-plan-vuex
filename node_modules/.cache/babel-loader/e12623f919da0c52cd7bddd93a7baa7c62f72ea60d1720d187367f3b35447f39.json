{"ast":null,"code":"import { renderSlot as _renderSlot, normalizeStyle as _normalizeStyle, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = [\"width\", \"height\"];\nconst _hoisted_2 = [\"id\", \"fx\", \"fy\", \"cx\", \"cy\", \"r\"];\nconst _hoisted_3 = [\"stop-color\"];\nconst _hoisted_4 = [\"stop-color\"];\nconst _hoisted_5 = [\"r\", \"cx\", \"cy\", \"stroke\", \"stroke-dasharray\", \"stroke-linecap\"];\nconst _hoisted_6 = [\"transform\", \"r\", \"cx\", \"cy\", \"stroke\", \"stroke-dasharray\", \"stroke-dashoffset\", \"stroke-linecap\"];\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", {\n    class: \"radial-progress-container\",\n    style: _normalizeStyle($options.containerStyle)\n  }, [_createElementVNode(\"div\", {\n    class: \"radial-progress-inner\",\n    style: _normalizeStyle($options.innerCircleStyle)\n  }, [_renderSlot(_ctx.$slots, \"default\")], 4 /* STYLE */), (_openBlock(), _createElementBlock(\"svg\", {\n    class: \"radial-progress-bar\",\n    width: $props.diameter,\n    height: $props.diameter,\n    version: \"1.1\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  }, [_createElementVNode(\"defs\", null, [_createElementVNode(\"radialGradient\", {\n    id: 'radial-gradient' + _ctx._uid,\n    fx: $data.gradient.fx,\n    fy: $data.gradient.fy,\n    cx: $data.gradient.cx,\n    cy: $data.gradient.cy,\n    r: $data.gradient.r\n  }, [_createElementVNode(\"stop\", {\n    offset: \"30%\",\n    \"stop-color\": $props.startColor\n  }, null, 8 /* PROPS */, _hoisted_3), _createElementVNode(\"stop\", {\n    offset: \"100%\",\n    \"stop-color\": $props.stopColor\n  }, null, 8 /* PROPS */, _hoisted_4)], 8 /* PROPS */, _hoisted_2)]), _createElementVNode(\"circle\", {\n    r: $options.innerCircleRadius,\n    cx: $options.radius,\n    cy: $options.radius,\n    fill: \"transparent\",\n    stroke: $props.innerStrokeColor,\n    \"stroke-dasharray\": $options.circumference,\n    \"stroke-dashoffset\": \"0\",\n    \"stroke-linecap\": $props.strokeLinecap,\n    style: _normalizeStyle($options.strokeStyle)\n  }, null, 12 /* STYLE, PROPS */, _hoisted_5), _createElementVNode(\"circle\", {\n    transform: 'rotate(270, ' + $options.radius + ',' + $options.radius + ')',\n    r: $options.innerCircleRadius,\n    cx: $options.radius,\n    cy: $options.radius,\n    fill: \"transparent\",\n    stroke: 'url(#radial-gradient' + _ctx._uid + ')',\n    \"stroke-dasharray\": $options.circumference,\n    \"stroke-dashoffset\": $options.circumference,\n    \"stroke-linecap\": $props.strokeLinecap,\n    style: _normalizeStyle($options.progressStyle)\n  }, null, 12 /* STYLE, PROPS */, _hoisted_6)], 8 /* PROPS */, _hoisted_1))], 4 /* STYLE */);\n}","map":{"version":3,"mappings":";;;;;;;;uBACEA,oBAwCM;IAxCDC,KAAK,EAAC,2BAA2B;IAAEC,KAAK,kBAAEC,uBAAc;MAC3DC,oBAEM;IAFDH,KAAK,EAAC,uBAAuB;IAAEC,KAAK,kBAAEC,yBAAgB;MACzDE,YAAaC,yDAEfN,oBAmCM;IAnCDC,KAAK,EAAC,qBAAqB;IAC1BM,KAAK,EAAEC,eAAQ;IACfC,MAAM,EAAED,eAAQ;IACjBE,OAAO,EAAC,KAAK;IACbC,KAAK,EAAC;MACTP,oBAUO,eATLA,oBAQiB;IARAQ,EAAE,sBAAsBN,SAAI;IAC5BO,EAAE,EAAEC,cAAQ,CAACD,EAAE;IACfE,EAAE,EAAED,cAAQ,CAACC,EAAE;IACfC,EAAE,EAAEF,cAAQ,CAACE,EAAE;IACfC,EAAE,EAAEH,cAAQ,CAACG,EAAE;IACfC,CAAC,EAAEJ,cAAQ,CAACI;MAC3Bd,oBAA6C;IAAvCe,MAAM,EAAC,KAAK;IAAE,YAAU,EAAEX;uCAChCJ,oBAA6C;IAAvCe,MAAM,EAAC,MAAM;IAAE,YAAU,EAAEX;sEAGrCJ,oBAQsC;IAR7Bc,CAAC,EAAEf,0BAAiB;IACpBa,EAAE,EAAEb,eAAM;IACVc,EAAE,EAAEd,eAAM;IACXiB,IAAI,EAAC,aAAa;IACjBC,MAAM,EAAEb,uBAAgB;IACxB,kBAAgB,EAAEL,sBAAa;IAChC,mBAAiB,EAAC,GAAG;IACpB,gBAAc,EAAEK,oBAAa;IAC7BN,KAAK,kBAAEC,oBAAW;+CAC3BC,oBASwC;IAT/BkB,SAAS,mBAAmBnB,eAAM,SAASA,eAAM;IACjDe,CAAC,EAAEf,0BAAiB;IACpBa,EAAE,EAAEb,eAAM;IACVc,EAAE,EAAEd,eAAM;IACXiB,IAAI,EAAC,aAAa;IACjBC,MAAM,2BAA2Bf,SAAI;IACrC,kBAAgB,EAAEH,sBAAa;IAC/B,mBAAiB,EAAEA,sBAAa;IAChC,gBAAc,EAAEK,oBAAa;IAC7BN,KAAK,kBAAEC,sBAAa","names":["_createElementBlock","class","style","$options","_createElementVNode","_renderSlot","_ctx","width","$props","height","version","xmlns","id","fx","$data","fy","cx","cy","r","offset","fill","stroke","transform"],"sourceRoot":"","sources":["C:\\Users\\User\\vue-chart\\node_modules\\vue-radial-progress\\src\\RadialProgressBar.vue"],"sourcesContent":["<template>\n  <div class=\"radial-progress-container\" :style=\"containerStyle\">\n    <div class=\"radial-progress-inner\" :style=\"innerCircleStyle\">\n      <slot></slot>\n    </div>\n    <svg class=\"radial-progress-bar\"\n         :width=\"diameter\"\n         :height=\"diameter\"\n         version=\"1.1\"\n         xmlns=\"http://www.w3.org/2000/svg\">\n      <defs>\n        <radialGradient :id=\"'radial-gradient' + _uid\"\n                        :fx=\"gradient.fx\"\n                        :fy=\"gradient.fy\"\n                        :cx=\"gradient.cx\"\n                        :cy=\"gradient.cy\"\n                        :r=\"gradient.r\">\n          <stop offset=\"30%\" :stop-color=\"startColor\"/>\n          <stop offset=\"100%\" :stop-color=\"stopColor\"/>\n        </radialGradient>\n      </defs>\n      <circle :r=\"innerCircleRadius\"\n              :cx=\"radius\"\n              :cy=\"radius\"\n              fill=\"transparent\"\n              :stroke=\"innerStrokeColor\"\n              :stroke-dasharray=\"circumference\"\n              stroke-dashoffset=\"0\"\n              :stroke-linecap=\"strokeLinecap\"\n              :style=\"strokeStyle\"></circle>\n      <circle :transform=\"'rotate(270, ' + radius + ',' + radius + ')'\"\n              :r=\"innerCircleRadius\"\n              :cx=\"radius\"\n              :cy=\"radius\"\n              fill=\"transparent\"\n              :stroke=\"'url(#radial-gradient' + _uid + ')'\"\n              :stroke-dasharray=\"circumference\"\n              :stroke-dashoffset=\"circumference\"\n              :stroke-linecap=\"strokeLinecap\"\n              :style=\"progressStyle\"></circle>\n    </svg>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    diameter: {\n      type: Number,\n      required: false,\n      default: 200\n    },\n    totalSteps: {\n      type: Number,\n      required: true,\n      default: 10\n    },\n    completedSteps: {\n      type: Number,\n      required: true,\n      default: 0\n    },\n    startColor: {\n      type: String,\n      required: false,\n      default: '#bbff42'\n    },\n    stopColor: {\n      type: String,\n      required: false,\n      default: '#429321'\n    },\n    strokeWidth: {\n      type: Number,\n      required: false,\n      default: 10\n    },\n    innerStrokeWidth: {\n      type: Number,\n      required: false,\n      default: 10\n    },\n    strokeLinecap: {\n      type: String,\n      required: false,\n      default: 'round'\n    },\n    animateSpeed: {\n      type: Number,\n      required: false,\n      default: 1000\n    },\n    innerStrokeColor: {\n      type: String,\n      required: false,\n      default: '#323232'\n    },\n    fps: {\n      type: Number,\n      required: false,\n      default: 60\n    },\n    timingFunc: {\n      type: String,\n      required: false,\n      default: 'linear'\n    },\n    isClockwise: {\n      type: Boolean,\n      required: false,\n      default: true\n    }\n  },\n\n  data () {\n    return {\n      gradient: {\n        fx: 0.99,\n        fy: 0.5,\n        cx: 0.5,\n        cy: 0.5,\n        r: 0.65\n      },\n      gradientAnimation: null,\n      currentAngle: 0,\n      strokeDashoffset: 0\n    }\n  },\n\n  computed: {\n    radius () {\n      return this.diameter / 2\n    },\n\n    circumference () {\n      return Math.PI * this.innerCircleDiameter\n    },\n\n    stepSize () {\n      if (this.totalSteps === 0) {\n        return 0\n      }\n\n      return 100 / this.totalSteps\n    },\n\n    finishedPercentage () {\n      return this.stepSize * this.completedSteps\n    },\n\n    circleSlice () {\n      return 2 * Math.PI / this.totalSteps\n    },\n\n    animateSlice () {\n      return this.circleSlice / this.totalPoints\n    },\n\n    innerCircleDiameter () {\n      return this.diameter - (this.innerStrokeWidth * 2)\n    },\n\n    innerCircleRadius () {\n      return this.innerCircleDiameter / 2\n    },\n\n    totalPoints () {\n      return this.animateSpeed / this.animationIncrements\n    },\n\n    animationIncrements () {\n      return 1000 / this.fps\n    },\n\n    hasGradient () {\n      return this.startColor !== this.stopColor\n    },\n\n    containerStyle () {\n      return {\n        height: `${this.diameter}px`,\n        width: `${this.diameter}px`\n      }\n    },\n\n    progressStyle () {\n      return {\n        height: `${this.diameter}px`,\n        width: `${this.diameter}px`,\n        strokeWidth: `${this.strokeWidth}px`,\n        strokeDashoffset: this.strokeDashoffset,\n        transition: `stroke-dashoffset ${this.animateSpeed}ms ${this.timingFunc}`\n      }\n    },\n\n    strokeStyle () {\n      return {\n        height: `${this.diameter}px`,\n        width: `${this.diameter}px`,\n        strokeWidth: `${this.innerStrokeWidth}px`\n      }\n    },\n\n    innerCircleStyle () {\n      return {\n        width: `${this.innerCircleDiameter}px`\n      }\n    },\n  },\n\n  methods: {\n    getStopPointsOfCircle (steps) {\n      const points = []\n\n      for (let i = 0; i < steps; i++) {\n        const angle = this.circleSlice * i\n        points.push(this.getPointOfCircle(angle))\n      }\n\n      return points\n    },\n\n    getPointOfCircle (angle) {\n      const radius = 0.5\n\n      const x = radius + (radius * Math.cos(angle))\n      const y = radius + (radius * Math.sin(angle))\n\n      return { x, y }\n    },\n\n    gotoPoint () {\n      const point = this.getPointOfCircle(this.currentAngle)\n\n      if (point.x && point.y) {\n        this.gradient.fx = point.x\n        this.gradient.fy = point.y\n      }\n    },\n\n    direction () {\n      if (this.isClockwise) {\n        return 1\n      }\n      return -1\n    },\n\n    changeProgress ({ isAnimate = true }) {\n      this.strokeDashoffset = ((100 - this.finishedPercentage) / 100) * this.circumference * this.direction()\n\n      if (this.gradientAnimation) {\n        clearInterval(this.gradientAnimation)\n      }\n\n      if (!isAnimate) {\n        this.gotoNextStep()\n        return\n      }\n\n      const angleOffset = (this.completedSteps - 1) * this.circleSlice\n      let i = (this.currentAngle - angleOffset) / this.animateSlice\n      const incrementer = Math.abs(i - this.totalPoints) / this.totalPoints\n      const isMoveForward = i < this.totalPoints\n\n      this.gradientAnimation = setInterval(() => {\n        if (isMoveForward && i >= this.totalPoints ||\n            !isMoveForward && i < this.totalPoints) {\n          clearInterval(this.gradientAnimation)\n          return\n        }\n\n        this.currentAngle = angleOffset + (this.animateSlice * i)\n        this.gotoPoint()\n\n        i += isMoveForward ? incrementer : -incrementer\n      }, this.animationIncrements)\n    },\n\n    gotoNextStep () {\n      this.currentAngle = this.completedSteps * this.circleSlice\n      this.gotoPoint()\n    }\n  },\n\n  watch: {\n    totalSteps () {\n      this.changeProgress({ isAnimate: true })\n    },\n\n    completedSteps () {\n      this.changeProgress({ isAnimate: true })\n    },\n\n    diameter () {\n      this.changeProgress({ isAnimate: true })\n    },\n\n    strokeWidth () {\n      this.changeProgress({ isAnimate: true })\n    }\n  },\n\n  created () {\n    this.changeProgress({ isAnimate: false })\n  }\n}\n</script>\n\n<style>\n.radial-progress-container {\n  position: relative;\n}\n\n.radial-progress-inner {\n  position: absolute;\n  top: 0; right: 0; bottom: 0; left: 0;\n  position: absolute;\n  border-radius: 50%;\n  margin: 0 auto;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n</style>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}